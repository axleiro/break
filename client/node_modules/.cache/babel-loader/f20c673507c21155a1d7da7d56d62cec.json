{"ast":null,"code":"var _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/game.tsx\";\nimport React from \"react\";\nimport { useHistory, useRouteMatch, useLocation } from \"react-router-dom\";\nimport { useConfig, useRefreshAccounts, useAccounts, useIsFetching, useClearAccounts, useConnection } from \"providers/api\";\nimport { useSocket } from \"providers/socket\";\nimport { useBlockhash } from \"providers/blockhash\";\nimport { useDispatch, ActionType } from \"providers/transactions\";\nexport const COUNTDOWN_SECS = 15;\nconst GameStateContext = React.createContext(undefined);\nconst CountdownContext = React.createContext(undefined);\nexport function GameStateProvider({\n  children\n}) {\n  const [countdown, setCountdown] = React.useState();\n  const [gameState, setGameState] = React.useState(\"loading\");\n  const resultsTimerRef = React.useRef();\n  const connection = useConnection();\n  const history = useHistory();\n  const location = useLocation();\n  const blockhash = useBlockhash();\n  const config = useConfig();\n  const accounts = useAccounts();\n  const socket = useSocket();\n  const isResultsRoute = !!useRouteMatch(\"/results\");\n  const isGameRoute = !!useRouteMatch(\"/game\");\n  const isFetching = useIsFetching();\n  React.useEffect(() => {\n    setCountdown(undefined);\n  }, [isGameRoute, connection]);\n  React.useEffect(() => {\n    const paymentRequired = (config === null || config === void 0 ? void 0 : config.paymentRequired) === true;\n    const needsPayment = paymentRequired && !isFetching && !accounts;\n    const doneLoading = blockhash && config && socket && (needsPayment || accounts);\n\n    if (!doneLoading) {\n      setGameState(\"loading\");\n    } else if (needsPayment) {\n      setGameState(\"payment\");\n    } else {\n      setGameState(gameState => {\n        if (gameState === \"loading\" || gameState === \"payment\") {\n          return isResultsRoute ? \"reset\" : \"play\";\n        }\n\n        return gameState;\n      });\n    }\n  }, [isResultsRoute, isFetching, blockhash, config, accounts, socket]);\n  React.useEffect(() => {\n    if (countdown !== undefined) {\n      if (!resultsTimerRef.current) {\n        resultsTimerRef.current = setTimeout(() => {\n          setGameState(\"reset\");\n          history.push({ ...location,\n            pathname: \"/results\"\n          });\n        }, COUNTDOWN_SECS * 1000);\n      }\n    } else if (resultsTimerRef.current) {\n      clearTimeout(resultsTimerRef.current);\n      resultsTimerRef.current = undefined;\n    }\n  }, [countdown, history, location]);\n  return /*#__PURE__*/React.createElement(GameStateContext.Provider, {\n    value: [gameState, setGameState],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 82,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(CountdownContext.Provider, {\n    value: [countdown, setCountdown],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 83,\n      columnNumber: 7\n    }\n  }, children));\n}\nexport function useGameState() {\n  const context = React.useContext(GameStateContext);\n\n  if (!context) {\n    throw new Error(`useGameState must be used within a GameStateProvider`);\n  }\n\n  return context;\n}\nexport function useCountdown() {\n  const context = React.useContext(CountdownContext);\n\n  if (!context) {\n    throw new Error(`useCountdown must be used within a GameStateProvider`);\n  }\n\n  return context;\n}\nexport function useResetGame() {\n  var _useConfig;\n\n  const refreshAccounts = useRefreshAccounts();\n  const paymentRequired = (_useConfig = useConfig()) === null || _useConfig === void 0 ? void 0 : _useConfig.paymentRequired;\n  const clearAccounts = useClearAccounts();\n  const history = useHistory();\n  const location = useLocation();\n  const dispatch = useDispatch();\n  return React.useCallback(() => {\n    dispatch({\n      type: ActionType.ResetState\n    });\n    history.push({ ...location,\n      pathname: \"/game\"\n    });\n\n    if (paymentRequired) {\n      clearAccounts();\n    } else {\n      refreshAccounts();\n    }\n  }, [refreshAccounts, paymentRequired, clearAccounts, history, location, dispatch]);\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/game.tsx"],"names":["React","useHistory","useRouteMatch","useLocation","useConfig","useRefreshAccounts","useAccounts","useIsFetching","useClearAccounts","useConnection","useSocket","useBlockhash","useDispatch","ActionType","COUNTDOWN_SECS","GameStateContext","createContext","undefined","CountdownContext","GameStateProvider","children","countdown","setCountdown","useState","gameState","setGameState","resultsTimerRef","useRef","connection","history","location","blockhash","config","accounts","socket","isResultsRoute","isGameRoute","isFetching","useEffect","paymentRequired","needsPayment","doneLoading","current","setTimeout","push","pathname","clearTimeout","useGameState","context","useContext","Error","useCountdown","useResetGame","refreshAccounts","clearAccounts","dispatch","useCallback","type","ResetState"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { useHistory, useRouteMatch, useLocation } from \"react-router-dom\";\nimport {\n  useConfig,\n  useRefreshAccounts,\n  useAccounts,\n  useIsFetching,\n  useClearAccounts,\n  useConnection,\n} from \"providers/api\";\nimport { useSocket } from \"providers/socket\";\nimport { useBlockhash } from \"providers/blockhash\";\nimport { useDispatch, ActionType } from \"providers/transactions\";\n\nexport const COUNTDOWN_SECS = 15;\n\ntype GameState = \"loading\" | \"payment\" | \"play\" | \"reset\";\ntype SetGameState = React.Dispatch<React.SetStateAction<GameState>>;\nconst GameStateContext = React.createContext<\n  [GameState, SetGameState] | undefined\n>(undefined);\n\ntype SetCountdown = React.Dispatch<React.SetStateAction<number | undefined>>;\nconst CountdownContext = React.createContext<\n  [number | undefined, SetCountdown] | undefined\n>(undefined);\n\ntype Props = { children: React.ReactNode };\nexport function GameStateProvider({ children }: Props) {\n  const [countdown, setCountdown] = React.useState<number>();\n  const [gameState, setGameState] = React.useState<GameState>(\"loading\");\n  const resultsTimerRef = React.useRef<NodeJS.Timer>();\n  const connection = useConnection();\n  const history = useHistory();\n  const location = useLocation();\n  const blockhash = useBlockhash();\n  const config = useConfig();\n  const accounts = useAccounts();\n  const socket = useSocket();\n  const isResultsRoute = !!useRouteMatch(\"/results\");\n  const isGameRoute = !!useRouteMatch(\"/game\");\n  const isFetching = useIsFetching();\n\n  React.useEffect(() => {\n    setCountdown(undefined);\n  }, [isGameRoute, connection]);\n\n  React.useEffect(() => {\n    const paymentRequired = config?.paymentRequired === true;\n    const needsPayment = paymentRequired && !isFetching && !accounts;\n    const doneLoading =\n      blockhash && config && socket && (needsPayment || accounts);\n    if (!doneLoading) {\n      setGameState(\"loading\");\n    } else if (needsPayment) {\n      setGameState(\"payment\");\n    } else {\n      setGameState((gameState) => {\n        if (gameState === \"loading\" || gameState === \"payment\") {\n          return isResultsRoute ? \"reset\" : \"play\";\n        }\n        return gameState;\n      });\n    }\n  }, [isResultsRoute, isFetching, blockhash, config, accounts, socket]);\n\n  React.useEffect(() => {\n    if (countdown !== undefined) {\n      if (!resultsTimerRef.current) {\n        resultsTimerRef.current = setTimeout(() => {\n          setGameState(\"reset\");\n          history.push({ ...location, pathname: \"/results\" });\n        }, COUNTDOWN_SECS * 1000);\n      }\n    } else if (resultsTimerRef.current) {\n      clearTimeout(resultsTimerRef.current);\n      resultsTimerRef.current = undefined;\n    }\n  }, [countdown, history, location]);\n\n  return (\n    <GameStateContext.Provider value={[gameState, setGameState]}>\n      <CountdownContext.Provider value={[countdown, setCountdown]}>\n        {children}\n      </CountdownContext.Provider>\n    </GameStateContext.Provider>\n  );\n}\n\nexport function useGameState() {\n  const context = React.useContext(GameStateContext);\n  if (!context) {\n    throw new Error(`useGameState must be used within a GameStateProvider`);\n  }\n  return context;\n}\n\nexport function useCountdown() {\n  const context = React.useContext(CountdownContext);\n  if (!context) {\n    throw new Error(`useCountdown must be used within a GameStateProvider`);\n  }\n  return context;\n}\n\nexport function useResetGame() {\n  const refreshAccounts = useRefreshAccounts();\n  const paymentRequired = useConfig()?.paymentRequired;\n  const clearAccounts = useClearAccounts();\n  const history = useHistory();\n  const location = useLocation();\n  const dispatch = useDispatch();\n\n  return React.useCallback(() => {\n    dispatch({ type: ActionType.ResetState });\n    history.push({ ...location, pathname: \"/game\" });\n    if (paymentRequired) {\n      clearAccounts();\n    } else {\n      refreshAccounts();\n    }\n  }, [\n    refreshAccounts,\n    paymentRequired,\n    clearAccounts,\n    history,\n    location,\n    dispatch,\n  ]);\n}\n"]},"metadata":{},"sourceType":"module"}