{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/create.tsx\",\n    _s = $RefreshSig$();\n\nimport * as React from \"react\";\nimport bs58 from \"bs58\";\nimport { getCommitmentName, useDispatch } from \"./index\";\nimport { CreateTransactionRPC } from \"../../workers/create-transaction-rpc\";\nimport { useConfig, useAccounts } from \"providers/server/http\";\nimport { useBlockhash } from \"providers/rpc/blockhash\";\nimport { useSocket } from \"providers/server/socket\";\nimport { reportError } from \"utils\";\nimport { useConnection } from \"providers/rpc\";\nimport { DEBUG_MODE, subscribedCommitments } from \"./confirmed\";\nimport { useTargetSlotRef } from \"providers/slot\";\nconst SEND_TIMEOUT_MS = 45000;\nconst RETRY_INTERVAL_MS = 500;\nconst workerRPC = new CreateTransactionRPC();\nexport const CreateTxContext = /*#__PURE__*/React.createContext(undefined);\nexport function CreateTxProvider({\n  children\n}) {\n  _s();\n\n  const createTx = React.useRef(() => {});\n  const config = useConfig();\n  const accounts = useAccounts();\n  const idCounter = React.useRef(0);\n  const targetSlotRef = useTargetSlotRef();\n  const programDataAccount = accounts === null || accounts === void 0 ? void 0 : accounts.programAccounts[0].toBase58(); // Reset counter when program data accounts are refreshed\n\n  React.useEffect(() => {\n    idCounter.current = 0;\n  }, [programDataAccount]);\n  const connection = useConnection();\n  const blockhash = useBlockhash();\n  const dispatch = useDispatch();\n  const socket = useSocket();\n  React.useEffect(() => {\n    createTx.current = () => {\n      if (!connection || !blockhash || !socket || !config || !accounts || !targetSlotRef.current) return;\n      const id = idCounter.current;\n\n      if (id < accounts.accountCapacity * accounts.programAccounts.length) {\n        idCounter.current++;\n        createTransaction(connection, blockhash, targetSlotRef.current, config.programId, accounts, id, dispatch, socket);\n      } else {\n        reportError(new Error(\"Account capacity exceeded\"), \"failed to create transaction\");\n      }\n    };\n  }, [blockhash, connection, socket, config, accounts, dispatch, targetSlotRef]);\n  return /*#__PURE__*/_jsxDEV(CreateTxContext.Provider, {\n    value: createTx,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 92,\n    columnNumber: 5\n  }, this);\n}\n\n_s(CreateTxProvider, \"0K+pe4trwtb990TxstCpBdr+O9Y=\", false, function () {\n  return [useConfig, useAccounts, useTargetSlotRef, useConnection, useBlockhash, useDispatch, useSocket];\n});\n\n_c = CreateTxProvider;\nexport function createTransaction(connection, blockhash, targetSlot, programId, accounts, trackingId, dispatch, socket) {\n  const {\n    feeAccounts,\n    programAccounts\n  } = accounts;\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n  workerRPC.createTransaction({\n    trackingId: trackingId,\n    blockhash: blockhash,\n    programId: programId.toBase58(),\n    programDataAccount: programDataAccount.toBase58(),\n    bitId: bitId,\n    feeAccountSecretKey: feeAccount.secretKey\n  }).then(response => {\n    const {\n      signature,\n      serializedTransaction\n    } = response;\n    socket.send(serializedTransaction);\n    const sentAt = performance.now();\n    const pendingTransaction = {\n      sentAt,\n      targetSlot\n    };\n    pendingTransaction.timeoutId = window.setTimeout(() => {\n      dispatch({\n        type: \"timeout\",\n        trackingId\n      });\n    }, SEND_TIMEOUT_MS);\n    const encodedSignature = bs58.encode(signature);\n    const details = {\n      id: bitId,\n      feeAccount: feeAccount.publicKey,\n      programAccount: programDataAccount,\n      signature: encodedSignature\n    };\n\n    if (DEBUG_MODE) {\n      const maxId = connection.onTransaction(encodedSignature, (notification, context) => {\n        if (notification.type === \"received\") {\n          dispatch({\n            type: \"received\",\n            trackingId,\n            slot: context.slot,\n            receivedAt: performance.now()\n          });\n          connection.removeSignatureListener(maxId);\n        }\n      }, {\n        commitment: \"max\",\n        enableReceivedNotification: true\n      });\n      const commitments = subscribedCommitments();\n      commitments.forEach(commitment => {\n        connection.onTransaction(encodedSignature, (notification, context) => {\n          const commitmentName = getCommitmentName(commitment);\n          dispatch({\n            type: \"track\",\n            commitment,\n            trackingId,\n            slot: context.slot,\n            receivedAt: performance.now()\n          });\n        }, {\n          commitment\n        });\n      });\n    }\n\n    dispatch({\n      type: \"new\",\n      details,\n      trackingId,\n      pendingTransaction\n    });\n    const retry = new URLSearchParams(window.location.search).get(\"retry\");\n\n    if (retry === null || retry !== \"disabled\") {\n      pendingTransaction.retryId = window.setInterval(() => {\n        if (socket.readyState === WebSocket.OPEN) {\n          socket.send(serializedTransaction);\n        }\n      }, RETRY_INTERVAL_MS);\n    }\n  }, error => {\n    console.error(error);\n  });\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"CreateTxProvider\");","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/create.tsx"],"names":["React","bs58","getCommitmentName","useDispatch","CreateTransactionRPC","useConfig","useAccounts","useBlockhash","useSocket","reportError","useConnection","DEBUG_MODE","subscribedCommitments","useTargetSlotRef","SEND_TIMEOUT_MS","RETRY_INTERVAL_MS","workerRPC","CreateTxContext","createContext","undefined","CreateTxProvider","children","createTx","useRef","config","accounts","idCounter","targetSlotRef","programDataAccount","programAccounts","toBase58","useEffect","current","connection","blockhash","dispatch","socket","id","accountCapacity","length","createTransaction","programId","Error","targetSlot","trackingId","feeAccounts","bitId","Math","floor","accountIndex","feeAccount","feeAccountSecretKey","secretKey","then","response","signature","serializedTransaction","send","sentAt","performance","now","pendingTransaction","timeoutId","window","setTimeout","type","encodedSignature","encode","details","publicKey","programAccount","maxId","onTransaction","notification","context","slot","receivedAt","removeSignatureListener","commitment","enableReceivedNotification","commitments","forEach","commitmentName","retry","URLSearchParams","location","search","get","retryId","setInterval","readyState","WebSocket","OPEN","error","console"],"mappings":";;;;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,OAAOC,IAAP,MAAiB,MAAjB;AACA,SAEEC,iBAFF,EAKEC,WALF,QAMO,SANP;AAQA,SACEC,oBADF,QAGO,sCAHP;AAIA,SAASC,SAAT,EAAoBC,WAApB,QAAuC,uBAAvC;AACA,SAASC,YAAT,QAA6B,yBAA7B;AACA,SAASC,SAAT,QAA0B,yBAA1B;AACA,SAASC,WAAT,QAA4B,OAA5B;AACA,SAASC,aAAT,QAA8B,eAA9B;AACA,SAASC,UAAT,EAAqBC,qBAArB,QAAkD,aAAlD;AACA,SAASC,gBAAT,QAAiC,gBAAjC;AAEA,MAAMC,eAAe,GAAG,KAAxB;AACA,MAAMC,iBAAiB,GAAG,GAA1B;AAEA,MAAMC,SAAS,GAAG,IAAIZ,oBAAJ,EAAlB;AACA,OAAO,MAAMa,eAAe,gBAAGjB,KAAK,CAACkB,aAAN,CAE7BC,SAF6B,CAAxB;AAKP,OAAO,SAASC,gBAAT,CAA0B;AAAEC,EAAAA;AAAF,CAA1B,EAAuD;AAAA;;AAC5D,QAAMC,QAAQ,GAAGtB,KAAK,CAACuB,MAAN,CAAa,MAAM,CAAE,CAArB,CAAjB;AACA,QAAMC,MAAM,GAAGnB,SAAS,EAAxB;AACA,QAAMoB,QAAQ,GAAGnB,WAAW,EAA5B;AACA,QAAMoB,SAAS,GAAG1B,KAAK,CAACuB,MAAN,CAAqB,CAArB,CAAlB;AACA,QAAMI,aAAa,GAAGd,gBAAgB,EAAtC;AACA,QAAMe,kBAAkB,GAAGH,QAAH,aAAGA,QAAH,uBAAGA,QAAQ,CAAEI,eAAV,CAA0B,CAA1B,EAA6BC,QAA7B,EAA3B,CAN4D,CAQ5D;;AACA9B,EAAAA,KAAK,CAAC+B,SAAN,CAAgB,MAAM;AACpBL,IAAAA,SAAS,CAACM,OAAV,GAAoB,CAApB;AACD,GAFD,EAEG,CAACJ,kBAAD,CAFH;AAIA,QAAMK,UAAU,GAAGvB,aAAa,EAAhC;AACA,QAAMwB,SAAS,GAAG3B,YAAY,EAA9B;AACA,QAAM4B,QAAQ,GAAGhC,WAAW,EAA5B;AACA,QAAMiC,MAAM,GAAG5B,SAAS,EAAxB;AACAR,EAAAA,KAAK,CAAC+B,SAAN,CAAgB,MAAM;AACpBT,IAAAA,QAAQ,CAACU,OAAT,GAAmB,MAAM;AACvB,UACE,CAACC,UAAD,IACA,CAACC,SADD,IAEA,CAACE,MAFD,IAGA,CAACZ,MAHD,IAIA,CAACC,QAJD,IAKA,CAACE,aAAa,CAACK,OANjB,EAQE;AACF,YAAMK,EAAE,GAAGX,SAAS,CAACM,OAArB;;AACA,UAAIK,EAAE,GAAGZ,QAAQ,CAACa,eAAT,GAA2Bb,QAAQ,CAACI,eAAT,CAAyBU,MAA7D,EAAqE;AACnEb,QAAAA,SAAS,CAACM,OAAV;AACAQ,QAAAA,iBAAiB,CACfP,UADe,EAEfC,SAFe,EAGfP,aAAa,CAACK,OAHC,EAIfR,MAAM,CAACiB,SAJQ,EAKfhB,QALe,EAMfY,EANe,EAOfF,QAPe,EAQfC,MARe,CAAjB;AAUD,OAZD,MAYO;AACL3B,QAAAA,WAAW,CACT,IAAIiC,KAAJ,CAAU,2BAAV,CADS,EAET,8BAFS,CAAX;AAID;AACF,KA7BD;AA8BD,GA/BD,EA+BG,CACDR,SADC,EAEDD,UAFC,EAGDG,MAHC,EAIDZ,MAJC,EAKDC,QALC,EAMDU,QANC,EAODR,aAPC,CA/BH;AAyCA,sBACE,QAAC,eAAD,CAAiB,QAAjB;AAA0B,IAAA,KAAK,EAAEL,QAAjC;AAAA,cACGD;AADH;AAAA;AAAA;AAAA;AAAA,UADF;AAKD;;GA/DeD,gB;UAECf,S,EACEC,W,EAEKO,gB,EAQHH,a,EACDH,Y,EACDJ,W,EACFK,S;;;KAhBDY,gB;AAiEhB,OAAO,SAASoB,iBAAT,CACLP,UADK,EAELC,SAFK,EAGLS,UAHK,EAILF,SAJK,EAKLhB,QALK,EAMLmB,UANK,EAOLT,QAPK,EAQLC,MARK,EASL;AACA,QAAM;AAAES,IAAAA,WAAF;AAAehB,IAAAA;AAAf,MAAmCJ,QAAzC;AAEA,QAAMqB,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWJ,UAAU,GAAGC,WAAW,CAACN,MAApC,CAAd;AACA,QAAMU,YAAY,GAAGL,UAAU,GAAGC,WAAW,CAACN,MAA9C;AACA,QAAMX,kBAAkB,GAAGC,eAAe,CAACoB,YAAD,CAA1C;AACA,QAAMC,UAAU,GAAGL,WAAW,CAACI,YAAD,CAA9B;AAEAjC,EAAAA,SAAS,CACNwB,iBADH,CACqB;AACjBI,IAAAA,UAAU,EAAEA,UADK;AAEjBV,IAAAA,SAAS,EAAEA,SAFM;AAGjBO,IAAAA,SAAS,EAAEA,SAAS,CAACX,QAAV,EAHM;AAIjBF,IAAAA,kBAAkB,EAAEA,kBAAkB,CAACE,QAAnB,EAJH;AAKjBgB,IAAAA,KAAK,EAAEA,KALU;AAMjBK,IAAAA,mBAAmB,EAAED,UAAU,CAACE;AANf,GADrB,EASGC,IATH,CAUKC,QAAD,IAAgD;AAC9C,UAAM;AAAEC,MAAAA,SAAF;AAAaC,MAAAA;AAAb,QAAuCF,QAA7C;AAEAlB,IAAAA,MAAM,CAACqB,IAAP,CAAYD,qBAAZ;AACA,UAAME,MAAM,GAAGC,WAAW,CAACC,GAAZ,EAAf;AAEA,UAAMC,kBAAsC,GAAG;AAAEH,MAAAA,MAAF;AAAUf,MAAAA;AAAV,KAA/C;AACAkB,IAAAA,kBAAkB,CAACC,SAAnB,GAA+BC,MAAM,CAACC,UAAP,CAAkB,MAAM;AACrD7B,MAAAA,QAAQ,CAAC;AAAE8B,QAAAA,IAAI,EAAE,SAAR;AAAmBrB,QAAAA;AAAnB,OAAD,CAAR;AACD,KAF8B,EAE5B9B,eAF4B,CAA/B;AAIA,UAAMoD,gBAAgB,GAAGjE,IAAI,CAACkE,MAAL,CAAYZ,SAAZ,CAAzB;AACA,UAAMa,OAA2B,GAAG;AAClC/B,MAAAA,EAAE,EAAES,KAD8B;AAElCI,MAAAA,UAAU,EAAEA,UAAU,CAACmB,SAFW;AAGlCC,MAAAA,cAAc,EAAE1C,kBAHkB;AAIlC2B,MAAAA,SAAS,EAAEW;AAJuB,KAApC;;AAOA,QAAIvD,UAAJ,EAAgB;AACd,YAAM4D,KAAK,GAAItC,UAAD,CAAoBuC,aAApB,CACZN,gBADY,EAEZ,CAACO,YAAD,EAAoBC,OAApB,KAAqC;AACnC,YAAID,YAAY,CAACR,IAAb,KAAsB,UAA1B,EAAsC;AACpC9B,UAAAA,QAAQ,CAAC;AACP8B,YAAAA,IAAI,EAAE,UADC;AAEPrB,YAAAA,UAFO;AAGP+B,YAAAA,IAAI,EAAED,OAAO,CAACC,IAHP;AAIPC,YAAAA,UAAU,EAAEjB,WAAW,CAACC,GAAZ;AAJL,WAAD,CAAR;AAMA3B,UAAAA,UAAU,CAAC4C,uBAAX,CAAmCN,KAAnC;AACD;AACF,OAZW,EAaZ;AACEO,QAAAA,UAAU,EAAE,KADd;AAEEC,QAAAA,0BAA0B,EAAE;AAF9B,OAbY,CAAd;AAmBA,YAAMC,WAAW,GAAGpE,qBAAqB,EAAzC;AACAoE,MAAAA,WAAW,CAACC,OAAZ,CAAqBH,UAAD,IAAgB;AACjC7C,QAAAA,UAAD,CAAoBuC,aAApB,CACEN,gBADF,EAEE,CAACO,YAAD,EAAoBC,OAApB,KAAqC;AACnC,gBAAMQ,cAAc,GAAGhF,iBAAiB,CAAC4E,UAAD,CAAxC;AACA3C,UAAAA,QAAQ,CAAC;AACP8B,YAAAA,IAAI,EAAE,OADC;AAEPa,YAAAA,UAFO;AAGPlC,YAAAA,UAHO;AAIP+B,YAAAA,IAAI,EAAED,OAAO,CAACC,IAJP;AAKPC,YAAAA,UAAU,EAAEjB,WAAW,CAACC,GAAZ;AALL,WAAD,CAAR;AAOD,SAXH,EAYE;AAAEkB,UAAAA;AAAF,SAZF;AAcD,OAfD;AAiBD;;AAED3C,IAAAA,QAAQ,CAAC;AACP8B,MAAAA,IAAI,EAAE,KADC;AAEPG,MAAAA,OAFO;AAGPxB,MAAAA,UAHO;AAIPiB,MAAAA;AAJO,KAAD,CAAR;AAOA,UAAMsB,KAAK,GAAG,IAAIC,eAAJ,CAAoBrB,MAAM,CAACsB,QAAP,CAAgBC,MAApC,EAA4CC,GAA5C,CAAgD,OAAhD,CAAd;;AACA,QAAIJ,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,UAAhC,EAA4C;AAC1CtB,MAAAA,kBAAkB,CAAC2B,OAAnB,GAA6BzB,MAAM,CAAC0B,WAAP,CAAmB,MAAM;AACpD,YAAIrD,MAAM,CAACsD,UAAP,KAAsBC,SAAS,CAACC,IAApC,EAA0C;AACxCxD,UAAAA,MAAM,CAACqB,IAAP,CAAYD,qBAAZ;AACD;AACF,OAJ4B,EAI1BzC,iBAJ0B,CAA7B;AAKD;AACF,GApFL,EAqFK8E,KAAD,IAAgB;AACdC,IAAAA,OAAO,CAACD,KAAR,CAAcA,KAAd;AACD,GAvFL;AAyFD","sourcesContent":["import * as React from \"react\";\nimport { Blockhash, PublicKey, Connection } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport {\n  Dispatch,\n  getCommitmentName,\n  PendingTransaction,\n  TransactionDetails,\n  useDispatch,\n} from \"./index\";\nimport { AccountsConfig } from \"../server/http/config\";\nimport {\n  CreateTransactionRPC,\n  CreateTransactionResponseMessage,\n} from \"../../workers/create-transaction-rpc\";\nimport { useConfig, useAccounts } from \"providers/server/http\";\nimport { useBlockhash } from \"providers/rpc/blockhash\";\nimport { useSocket } from \"providers/server/socket\";\nimport { reportError } from \"utils\";\nimport { useConnection } from \"providers/rpc\";\nimport { DEBUG_MODE, subscribedCommitments } from \"./confirmed\";\nimport { useTargetSlotRef } from \"providers/slot\";\n\nconst SEND_TIMEOUT_MS = 45000;\nconst RETRY_INTERVAL_MS = 500;\n\nconst workerRPC = new CreateTransactionRPC();\nexport const CreateTxContext = React.createContext<\n  React.MutableRefObject<() => void | undefined> | undefined\n>(undefined);\n\ntype ProviderProps = { children: React.ReactNode };\nexport function CreateTxProvider({ children }: ProviderProps) {\n  const createTx = React.useRef(() => {});\n  const config = useConfig();\n  const accounts = useAccounts();\n  const idCounter = React.useRef<number>(0);\n  const targetSlotRef = useTargetSlotRef();\n  const programDataAccount = accounts?.programAccounts[0].toBase58();\n\n  // Reset counter when program data accounts are refreshed\n  React.useEffect(() => {\n    idCounter.current = 0;\n  }, [programDataAccount]);\n\n  const connection = useConnection();\n  const blockhash = useBlockhash();\n  const dispatch = useDispatch();\n  const socket = useSocket();\n  React.useEffect(() => {\n    createTx.current = () => {\n      if (\n        !connection ||\n        !blockhash ||\n        !socket ||\n        !config ||\n        !accounts ||\n        !targetSlotRef.current\n      )\n        return;\n      const id = idCounter.current;\n      if (id < accounts.accountCapacity * accounts.programAccounts.length) {\n        idCounter.current++;\n        createTransaction(\n          connection,\n          blockhash,\n          targetSlotRef.current,\n          config.programId,\n          accounts,\n          id,\n          dispatch,\n          socket\n        );\n      } else {\n        reportError(\n          new Error(\"Account capacity exceeded\"),\n          \"failed to create transaction\"\n        );\n      }\n    };\n  }, [\n    blockhash,\n    connection,\n    socket,\n    config,\n    accounts,\n    dispatch,\n    targetSlotRef,\n  ]);\n\n  return (\n    <CreateTxContext.Provider value={createTx}>\n      {children}\n    </CreateTxContext.Provider>\n  );\n}\n\nexport function createTransaction(\n  connection: Connection,\n  blockhash: Blockhash,\n  targetSlot: number,\n  programId: PublicKey,\n  accounts: AccountsConfig,\n  trackingId: number,\n  dispatch: Dispatch,\n  socket: WebSocket\n) {\n  const { feeAccounts, programAccounts } = accounts;\n\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n\n  workerRPC\n    .createTransaction({\n      trackingId: trackingId,\n      blockhash: blockhash,\n      programId: programId.toBase58(),\n      programDataAccount: programDataAccount.toBase58(),\n      bitId: bitId,\n      feeAccountSecretKey: feeAccount.secretKey,\n    })\n    .then(\n      (response: CreateTransactionResponseMessage) => {\n        const { signature, serializedTransaction } = response;\n\n        socket.send(serializedTransaction);\n        const sentAt = performance.now();\n\n        const pendingTransaction: PendingTransaction = { sentAt, targetSlot };\n        pendingTransaction.timeoutId = window.setTimeout(() => {\n          dispatch({ type: \"timeout\", trackingId });\n        }, SEND_TIMEOUT_MS);\n\n        const encodedSignature = bs58.encode(signature);\n        const details: TransactionDetails = {\n          id: bitId,\n          feeAccount: feeAccount.publicKey,\n          programAccount: programDataAccount,\n          signature: encodedSignature,\n        };\n\n        if (DEBUG_MODE) {\n          const maxId = (connection as any).onTransaction(\n            encodedSignature,\n            (notification: any, context: any) => {\n              if (notification.type === \"received\") {\n                dispatch({\n                  type: \"received\",\n                  trackingId,\n                  slot: context.slot,\n                  receivedAt: performance.now(),\n                });\n                connection.removeSignatureListener(maxId);\n              }\n            },\n            {\n              commitment: \"max\",\n              enableReceivedNotification: true,\n            }\n          );\n\n          const commitments = subscribedCommitments();\n          commitments.forEach((commitment) => {\n            (connection as any).onTransaction(\n              encodedSignature,\n              (notification: any, context: any) => {\n                const commitmentName = getCommitmentName(commitment);\n                dispatch({\n                  type: \"track\",\n                  commitment,\n                  trackingId,\n                  slot: context.slot,\n                  receivedAt: performance.now(),\n                });\n              },\n              { commitment }\n            );\n          });\n\n        }\n\n        dispatch({\n          type: \"new\",\n          details,\n          trackingId,\n          pendingTransaction,\n        });\n\n        const retry = new URLSearchParams(window.location.search).get(\"retry\");\n        if (retry === null || retry !== \"disabled\") {\n          pendingTransaction.retryId = window.setInterval(() => {\n            if (socket.readyState === WebSocket.OPEN) {\n              socket.send(serializedTransaction);\n            }\n          }, RETRY_INTERVAL_MS);\n        }\n      },\n      (error: any) => {\n        console.error(error);\n      }\n    );\n}\n"]},"metadata":{},"sourceType":"module"}