{"ast":null,"code":"var _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/create.tsx\";\nimport * as React from \"react\";\nimport { Transaction, TransactionInstruction } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport * as Bytes from \"utils/bytes\";\nimport { ActionType, useTargetSlotRef, useDispatch } from \"./index\";\nimport { useConfig, useAccounts } from \"providers/api\";\nimport { useBlockhash } from \"providers/blockhash\";\nimport { useSocket } from \"providers/socket\";\nimport { reportError } from \"utils\";\nconst SEND_TIMEOUT_MS = 45000;\nconst RETRY_INTERVAL_MS = 500;\nexport const CreateTxContext = React.createContext(undefined);\nexport function CreateTxProvider({\n  children\n}) {\n  const createTx = React.useRef(() => {});\n  const config = useConfig();\n  const accounts = useAccounts();\n  const idCounter = React.useRef(0);\n  const targetSlotRef = useTargetSlotRef();\n  const programDataAccount = accounts === null || accounts === void 0 ? void 0 : accounts.programAccounts[0].toBase58(); // Reset counter when program data accounts are refreshed\n\n  React.useEffect(() => {\n    idCounter.current = 0;\n  }, [programDataAccount]);\n  const blockhash = useBlockhash();\n  const dispatch = useDispatch();\n  const socket = useSocket();\n  React.useEffect(() => {\n    createTx.current = () => {\n      if (!blockhash || !socket || !config || !accounts || !targetSlotRef.current) return;\n      const id = idCounter.current;\n\n      if (id < accounts.accountCapacity * accounts.programAccounts.length) {\n        idCounter.current++;\n        createTransaction(blockhash, targetSlotRef.current, config.programId, accounts, id, dispatch, socket);\n      } else {\n        reportError(new Error(\"Account capacity exceeded\"), \"failed to create transaction\");\n      }\n    };\n  }, [blockhash, socket, config, accounts, dispatch, targetSlotRef]);\n  return /*#__PURE__*/React.createElement(CreateTxContext.Provider, {\n    value: createTx,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 74,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function createTransaction(blockhash, targetSlot, programId, accounts, trackingId, dispatch, socket) {\n  const {\n    feeAccounts,\n    programAccounts\n  } = accounts;\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n  const instruction = new TransactionInstruction({\n    keys: [{\n      pubkey: programDataAccount,\n      isWritable: true,\n      isSigner: false\n    }],\n    programId,\n    data: Buffer.from(Bytes.instructionDataFromId(bitId))\n  });\n  const transaction = new Transaction();\n  transaction.add(instruction);\n  const sentAt = performance.now();\n  transaction.recentBlockhash = blockhash;\n  const start = performance.now();\n  transaction.sign(feeAccount); // console.log(\"SIGN\", performance.now() - start);\n\n  const next = performance.now();\n  const signatureBuffer = transaction.signature;\n  if (!signatureBuffer) throw new Error(\"Failed to sign transaction\");\n  const signature = bs58.encode(signatureBuffer);\n  const pendingTransaction = {\n    sentAt,\n    targetSlot\n  };\n  pendingTransaction.timeoutId = window.setTimeout(() => {\n    dispatch({\n      type: ActionType.TimeoutTransaction,\n      trackingId\n    });\n  }, SEND_TIMEOUT_MS);\n  const details = {\n    id: bitId,\n    feeAccount: feeAccount.publicKey,\n    programAccount: programDataAccount,\n    signature\n  };\n  dispatch({\n    type: ActionType.NewTransaction,\n    details,\n    trackingId,\n    pendingTransaction\n  });\n  setTimeout(() => {\n    const serialized = transaction.serialize();\n    socket.send(serialized); // console.log(\"SEND\", performance.now() - next);\n\n    const retryUntil = new URLSearchParams(window.location.search).get(\"retry_until\");\n\n    if (retryUntil === null || retryUntil !== \"disabled\") {\n      pendingTransaction.retryId = window.setInterval(() => {\n        if (socket.readyState === WebSocket.OPEN) {\n          socket.send(serialized);\n        }\n      }, RETRY_INTERVAL_MS);\n    }\n  }, 1);\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/create.tsx"],"names":["React","Transaction","TransactionInstruction","bs58","Bytes","ActionType","useTargetSlotRef","useDispatch","useConfig","useAccounts","useBlockhash","useSocket","reportError","SEND_TIMEOUT_MS","RETRY_INTERVAL_MS","CreateTxContext","createContext","undefined","CreateTxProvider","children","createTx","useRef","config","accounts","idCounter","targetSlotRef","programDataAccount","programAccounts","toBase58","useEffect","current","blockhash","dispatch","socket","id","accountCapacity","length","createTransaction","programId","Error","targetSlot","trackingId","feeAccounts","bitId","Math","floor","accountIndex","feeAccount","instruction","keys","pubkey","isWritable","isSigner","data","Buffer","from","instructionDataFromId","transaction","add","sentAt","performance","now","recentBlockhash","start","sign","next","signatureBuffer","signature","encode","pendingTransaction","timeoutId","window","setTimeout","type","TimeoutTransaction","details","publicKey","programAccount","NewTransaction","serialized","serialize","send","retryUntil","URLSearchParams","location","search","get","retryId","setInterval","readyState","WebSocket","OPEN"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport {\n  Blockhash,\n  Transaction,\n  TransactionInstruction,\n  PublicKey,\n} from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport * as Bytes from \"utils/bytes\";\nimport {\n  Dispatch,\n  PendingTransaction,\n  ActionType,\n  TransactionDetails,\n  useTargetSlotRef,\n  useDispatch,\n} from \"./index\";\nimport { AccountsConfig } from \"../api/config\";\nimport { useConfig, useAccounts } from \"providers/api\";\nimport { useBlockhash } from \"providers/blockhash\";\nimport { useSocket } from \"providers/socket\";\nimport { reportError } from \"utils\";\n\nconst SEND_TIMEOUT_MS = 45000;\nconst RETRY_INTERVAL_MS = 500;\n\nexport const CreateTxContext = React.createContext<\n  React.MutableRefObject<() => void | undefined> | undefined\n>(undefined);\n\ntype ProviderProps = { children: React.ReactNode };\nexport function CreateTxProvider({ children }: ProviderProps) {\n  const createTx = React.useRef(() => {});\n  const config = useConfig();\n  const accounts = useAccounts();\n  const idCounter = React.useRef<number>(0);\n  const targetSlotRef = useTargetSlotRef();\n  const programDataAccount = accounts?.programAccounts[0].toBase58();\n\n  // Reset counter when program data accounts are refreshed\n  React.useEffect(() => {\n    idCounter.current = 0;\n  }, [programDataAccount]);\n\n  const blockhash = useBlockhash();\n  const dispatch = useDispatch();\n  const socket = useSocket();\n  React.useEffect(() => {\n    createTx.current = () => {\n      if (!blockhash || !socket || !config || !accounts || !targetSlotRef.current)\n        return;\n      const id = idCounter.current;\n      if (id < accounts.accountCapacity * accounts.programAccounts.length) {\n        idCounter.current++;\n        createTransaction(\n          blockhash,\n          targetSlotRef.current,\n          config.programId,\n          accounts,\n          id,\n          dispatch,\n          socket\n        );\n      } else {\n        reportError(\n          new Error(\"Account capacity exceeded\"),\n          \"failed to create transaction\"\n        );\n      }\n    };\n  }, [blockhash, socket, config, accounts, dispatch, targetSlotRef]);\n\n  return (\n    <CreateTxContext.Provider value={createTx}>\n      {children}\n    </CreateTxContext.Provider>\n  );\n}\n\nexport function createTransaction(\n  blockhash: Blockhash,\n  targetSlot: number,\n  programId: PublicKey,\n  accounts: AccountsConfig,\n  trackingId: number,\n  dispatch: Dispatch,\n  socket: WebSocket\n) {\n  const { feeAccounts, programAccounts } = accounts;\n\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n  const instruction = new TransactionInstruction({\n    keys: [{ pubkey: programDataAccount, isWritable: true, isSigner: false }],\n    programId,\n    data: Buffer.from(Bytes.instructionDataFromId(bitId)),\n  });\n\n  const transaction = new Transaction();\n  transaction.add(instruction);\n\n  const sentAt = performance.now();\n  transaction.recentBlockhash = blockhash;\n  const start = performance.now();\n  transaction.sign(feeAccount);\n  // console.log(\"SIGN\", performance.now() - start);\n  const next = performance.now();\n  const signatureBuffer = transaction.signature;\n  if (!signatureBuffer) throw new Error(\"Failed to sign transaction\");\n  const signature = bs58.encode(signatureBuffer);\n  const pendingTransaction: PendingTransaction = { sentAt, targetSlot };\n  pendingTransaction.timeoutId = window.setTimeout(() => {\n    dispatch({ type: ActionType.TimeoutTransaction, trackingId });\n  }, SEND_TIMEOUT_MS);\n\n  const details: TransactionDetails = {\n    id: bitId,\n    feeAccount: feeAccount.publicKey,\n    programAccount: programDataAccount,\n    signature,\n  };\n\n  dispatch({\n    type: ActionType.NewTransaction,\n    details,\n    trackingId,\n    pendingTransaction,\n  });\n\n  setTimeout(() => {\n    const serialized = transaction.serialize();\n    socket.send(serialized);\n    // console.log(\"SEND\", performance.now() - next);\n\n    const retryUntil = new URLSearchParams(window.location.search).get(\n      \"retry_until\"\n    );\n    if (retryUntil === null || retryUntil !== \"disabled\") {\n      pendingTransaction.retryId = window.setInterval(() => {\n        if (socket.readyState === WebSocket.OPEN) {\n          socket.send(serialized);\n        }\n      }, RETRY_INTERVAL_MS);\n    }\n  }, 1);\n}\n"]},"metadata":{},"sourceType":"module"}