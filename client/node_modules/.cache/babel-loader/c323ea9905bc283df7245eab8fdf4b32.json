{"ast":null,"code":"var _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/game.tsx\";\nimport React from \"react\";\nimport { useHistory, useRouteMatch, useLocation } from \"react-router-dom\";\nimport { useConfig, useRefreshAccounts, useAccounts, useIsFetching, useClearAccounts, useConnection } from \"providers/api\";\nimport { useSocket } from \"providers/socket\";\nimport { useBlockhash } from \"providers/blockhash\";\nimport { useDispatch, ActionType } from \"providers/transactions\";\nexport const COUNTDOWN_SECS = 1500;\nconst GameStateContext = React.createContext(undefined);\nconst CountdownContext = React.createContext(undefined);\nexport function GameStateProvider({\n  children\n}) {\n  const [countdown, setCountdown] = React.useState();\n  const [gameState, setGameState] = React.useState(\"loading\");\n  const resultsTimerRef = React.useRef();\n  const connection = useConnection();\n  const history = useHistory();\n  const location = useLocation();\n  const blockhash = useBlockhash();\n  const config = useConfig();\n  const accounts = useAccounts();\n  const socket = useSocket();\n  const isResultsRoute = !!useRouteMatch(\"/results\");\n  const isGameRoute = !!useRouteMatch(\"/game\");\n  const isFetching = useIsFetching();\n  React.useEffect(() => {\n    setCountdown(undefined);\n  }, [isGameRoute, connection]);\n  React.useEffect(() => {\n    const paymentRequired = (config === null || config === void 0 ? void 0 : config.paymentRequired) === true;\n    const needsPayment = paymentRequired && !isFetching && !accounts;\n    const doneLoading = blockhash && config && socket && (needsPayment || accounts);\n\n    if (!doneLoading) {\n      console.log(\"GAME - LOADING\");\n      setGameState(\"loading\");\n    } else if (needsPayment) {\n      console.log(\"GAME - PAYMENT\");\n      setGameState(\"payment\");\n    } else {\n      setGameState(gameState => {\n        if (gameState === \"loading\" || gameState === \"payment\") {\n          console.log(\"GAME - RESET OR PLAY\");\n          return isResultsRoute ? \"reset\" : \"play\";\n        }\n\n        console.log(\"GAME - NOTHING\");\n        return gameState;\n      });\n    }\n  }, [isResultsRoute, isFetching, blockhash, config, accounts, socket]);\n  React.useEffect(() => {\n    if (countdown !== undefined) {\n      if (!resultsTimerRef.current) {\n        resultsTimerRef.current = setTimeout(() => {\n          console.log(\"GAME - RESET\");\n          setGameState(\"reset\");\n          history.push({ ...location,\n            pathname: \"/results\"\n          });\n        }, COUNTDOWN_SECS * 1000);\n      }\n    } else if (resultsTimerRef.current) {\n      clearTimeout(resultsTimerRef.current);\n      resultsTimerRef.current = undefined;\n    }\n  }, [countdown, history, location]);\n  return /*#__PURE__*/React.createElement(GameStateContext.Provider, {\n    value: gameState,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(CountdownContext.Provider, {\n    value: [countdown, setCountdown],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 87,\n      columnNumber: 7\n    }\n  }, children));\n}\nexport function useGameState() {\n  const context = React.useContext(GameStateContext);\n\n  if (!context) {\n    throw new Error(`useGameState must be used within a GameStateProvider`);\n  }\n\n  return context;\n}\nexport function useCountdown() {\n  const context = React.useContext(CountdownContext);\n\n  if (!context) {\n    throw new Error(`useCountdown must be used within a GameStateProvider`);\n  }\n\n  return context;\n}\nexport function useResetGame() {\n  var _useConfig;\n\n  const refreshAccounts = useRefreshAccounts();\n  const paymentRequired = (_useConfig = useConfig()) === null || _useConfig === void 0 ? void 0 : _useConfig.paymentRequired;\n  const clearAccounts = useClearAccounts();\n  const history = useHistory();\n  const location = useLocation();\n  const dispatch = useDispatch();\n  return React.useCallback(() => {\n    dispatch({\n      type: ActionType.ResetState\n    });\n    history.push({ ...location,\n      pathname: \"/game\"\n    });\n\n    if (paymentRequired) {\n      clearAccounts();\n    } else {\n      refreshAccounts();\n    }\n  }, [refreshAccounts, paymentRequired, clearAccounts, history, location, dispatch]);\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/game.tsx"],"names":["React","useHistory","useRouteMatch","useLocation","useConfig","useRefreshAccounts","useAccounts","useIsFetching","useClearAccounts","useConnection","useSocket","useBlockhash","useDispatch","ActionType","COUNTDOWN_SECS","GameStateContext","createContext","undefined","CountdownContext","GameStateProvider","children","countdown","setCountdown","useState","gameState","setGameState","resultsTimerRef","useRef","connection","history","location","blockhash","config","accounts","socket","isResultsRoute","isGameRoute","isFetching","useEffect","paymentRequired","needsPayment","doneLoading","console","log","current","setTimeout","push","pathname","clearTimeout","useGameState","context","useContext","Error","useCountdown","useResetGame","refreshAccounts","clearAccounts","dispatch","useCallback","type","ResetState"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { useHistory, useRouteMatch, useLocation } from \"react-router-dom\";\nimport {\n  useConfig,\n  useRefreshAccounts,\n  useAccounts,\n  useIsFetching,\n  useClearAccounts,\n  useConnection,\n} from \"providers/api\";\nimport { useSocket } from \"providers/socket\";\nimport { useBlockhash } from \"providers/blockhash\";\nimport { useDispatch, ActionType } from \"providers/transactions\";\n\nexport const COUNTDOWN_SECS = 1500;\n\ntype GameState = \"loading\" | \"payment\" | \"play\" | \"reset\";\nconst GameStateContext = React.createContext<\n  GameState | undefined\n>(undefined);\n\ntype SetCountdown = React.Dispatch<React.SetStateAction<number | undefined>>;\nconst CountdownContext = React.createContext<\n  [number | undefined, SetCountdown] | undefined\n>(undefined);\n\ntype Props = { children: React.ReactNode };\nexport function GameStateProvider({ children }: Props) {\n  const [countdown, setCountdown] = React.useState<number>();\n  const [gameState, setGameState] = React.useState<GameState>(\"loading\");\n  const resultsTimerRef = React.useRef<NodeJS.Timer>();\n  const connection = useConnection();\n  const history = useHistory();\n  const location = useLocation();\n  const blockhash = useBlockhash();\n  const config = useConfig();\n  const accounts = useAccounts();\n  const socket = useSocket();\n  const isResultsRoute = !!useRouteMatch(\"/results\");\n  const isGameRoute = !!useRouteMatch(\"/game\");\n  const isFetching = useIsFetching();\n\n  React.useEffect(() => {\n    setCountdown(undefined);\n  }, [isGameRoute, connection]);\n\n  React.useEffect(() => {\n    const paymentRequired = config?.paymentRequired === true;\n    const needsPayment = paymentRequired && !isFetching && !accounts;\n    const doneLoading =\n      blockhash && config && socket && (needsPayment || accounts);\n    if (!doneLoading) {\n      console.log(\"GAME - LOADING\");\n      setGameState(\"loading\");\n    } else if (needsPayment) {\n      console.log(\"GAME - PAYMENT\");\n      setGameState(\"payment\");\n    } else {\n      setGameState((gameState) => {\n        if (gameState === \"loading\" || gameState === \"payment\") {\n          console.log(\"GAME - RESET OR PLAY\");\n          return isResultsRoute ? \"reset\" : \"play\";\n        }\n        console.log(\"GAME - NOTHING\");\n        return gameState;\n      });\n    }\n  }, [isResultsRoute, isFetching, blockhash, config, accounts, socket]);\n\n  React.useEffect(() => {\n    if (countdown !== undefined) {\n      if (!resultsTimerRef.current) {\n        resultsTimerRef.current = setTimeout(() => {\n          console.log(\"GAME - RESET\");\n          setGameState(\"reset\");\n          history.push({ ...location, pathname: \"/results\" });\n        }, COUNTDOWN_SECS * 1000);\n      }\n    } else if (resultsTimerRef.current) {\n      clearTimeout(resultsTimerRef.current);\n      resultsTimerRef.current = undefined;\n    }\n  }, [countdown, history, location]);\n\n  return (\n    <GameStateContext.Provider value={gameState}>\n      <CountdownContext.Provider value={[countdown, setCountdown]}>\n        {children}\n      </CountdownContext.Provider>\n    </GameStateContext.Provider>\n  );\n}\n\nexport function useGameState() {\n  const context = React.useContext(GameStateContext);\n  if (!context) {\n    throw new Error(`useGameState must be used within a GameStateProvider`);\n  }\n  return context;\n}\n\nexport function useCountdown() {\n  const context = React.useContext(CountdownContext);\n  if (!context) {\n    throw new Error(`useCountdown must be used within a GameStateProvider`);\n  }\n  return context;\n}\n\nexport function useResetGame() {\n  const refreshAccounts = useRefreshAccounts();\n  const paymentRequired = useConfig()?.paymentRequired;\n  const clearAccounts = useClearAccounts();\n  const history = useHistory();\n  const location = useLocation();\n  const dispatch = useDispatch();\n\n  return React.useCallback(() => {\n    dispatch({ type: ActionType.ResetState });\n    history.push({ ...location, pathname: \"/game\" });\n    if (paymentRequired) {\n      clearAccounts();\n    } else {\n      refreshAccounts();\n    }\n  }, [\n    refreshAccounts,\n    paymentRequired,\n    clearAccounts,\n    history,\n    location,\n    dispatch,\n  ]);\n}\n"]},"metadata":{},"sourceType":"module"}