{"ast":null,"code":"import { configFromInit, configFromAccounts } from \"./config\";\nimport { sleep, reportError } from \"utils\";\nimport { ActionType } from \"./index\";\n\nconst SPLIT = (() => {\n  const split = parseInt(new URLSearchParams(window.location.search).get(\"split\") || \"\");\n\n  if (!isNaN(split)) {\n    return split;\n  }\n})();\n\nexport async function fetchWithRetry(dispatch, httpUrlRef, request) {\n  dispatch({\n    type: ActionType.Fetch,\n    url: httpUrlRef.current\n  });\n  const httpUrl = httpUrlRef.current;\n\n  while (httpUrl === httpUrlRef.current) {\n    let response;\n\n    switch (request.route) {\n      case \"accounts\":\n        {\n          response = await fetchAccounts(httpUrl, request.paymentAccount);\n          break;\n        }\n\n      case \"init\":\n        {\n          response = await fetchInit(httpUrl);\n        }\n    }\n\n    if (httpUrl !== httpUrlRef.current) break;\n\n    if (response === \"retry\") {\n      await sleep(2000);\n    } else {\n      dispatch(response);\n      break;\n    }\n  }\n}\n\nasync function fetchInit(httpUrl) {\n  try {\n    const body = JSON.stringify({\n      split: SPLIT\n    });\n    const response = await fetch(new Request(httpUrl + \"/init\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body\n    }));\n    const data = await response.json();\n\n    if (!(\"clusterUrl\" in data) || !(\"programId\" in data)) {\n      throw new Error(\"Received invalid response\");\n    }\n\n    return {\n      url: httpUrl,\n      type: ActionType.Initialize,\n      config: configFromInit(data)\n    };\n  } catch (err) {\n    reportError(err, \"/init failed\");\n    return \"retry\";\n  }\n}\n\nasync function fetchAccounts(httpUrl, paymentAccount) {\n  const postData = {};\n\n  if (SPLIT) {\n    postData.split = SPLIT;\n  }\n\n  if (paymentAccount) {\n    postData.paymentKey = Buffer.from(paymentAccount.secretKey).toString(\"base64\");\n  }\n\n  try {\n    const body = JSON.stringify(postData);\n    const response = await fetch(new Request(httpUrl + \"/accounts\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body\n    }));\n\n    if (response.status === 400) {\n      return {\n        type: ActionType.Failure,\n        url: httpUrl,\n        accounts: undefined\n      };\n    } else if (response.status === 500) {\n      const error = await response.text();\n      throw new Error(error);\n    } else {\n      const data = await response.json();\n\n      if (!(\"programAccounts\" in data) || !(\"feeAccounts\" in data) || !(\"accountCapacity\" in data)) {\n        throw new Error(\"Received invalid response\");\n      }\n\n      return {\n        type: ActionType.Ready,\n        url: httpUrl,\n        accounts: configFromAccounts(data)\n      };\n    }\n  } catch (err) {\n    reportError(err, \"/accounts failed\");\n    return \"retry\";\n  }\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/api/request.tsx"],"names":["configFromInit","configFromAccounts","sleep","reportError","ActionType","SPLIT","split","parseInt","URLSearchParams","window","location","search","get","isNaN","fetchWithRetry","dispatch","httpUrlRef","request","type","Fetch","url","current","httpUrl","response","route","fetchAccounts","paymentAccount","fetchInit","body","JSON","stringify","fetch","Request","method","headers","data","json","Error","Initialize","config","err","postData","paymentKey","Buffer","from","secretKey","toString","status","Failure","accounts","undefined","error","text","Ready"],"mappings":"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","sourcesContent":["import { configFromInit, configFromAccounts } from \"./config\";\nimport { sleep, reportError } from \"utils\";\nimport { Action, Dispatch, ActionType } from \"./index\";\nimport { Account } from \"@solana/web3.js\";\n\nconst SPLIT = ((): number | undefined => {\n  const split = parseInt(\n    new URLSearchParams(window.location.search).get(\"split\") || \"\"\n  );\n  if (!isNaN(split)) {\n    return split;\n  }\n})();\n\ntype InitRequest = {\n  route: \"init\";\n};\n\ntype AccountsRequest = {\n  route: \"accounts\";\n  paymentAccount: Account | undefined;\n};\n\ntype Request = AccountsRequest | InitRequest;\n\nexport async function fetchWithRetry(\n  dispatch: Dispatch,\n  httpUrlRef: React.MutableRefObject<string>,\n  request: Request\n) {\n  dispatch({\n    type: ActionType.Fetch,\n    url: httpUrlRef.current,\n  });\n\n  const httpUrl = httpUrlRef.current;\n  while (httpUrl === httpUrlRef.current) {\n    let response: Action | \"retry\";\n    switch (request.route) {\n      case \"accounts\": {\n        response = await fetchAccounts(httpUrl, request.paymentAccount);\n        break;\n      }\n      case \"init\": {\n        response = await fetchInit(httpUrl);\n      }\n    }\n\n    if (httpUrl !== httpUrlRef.current) break;\n    if (response === \"retry\") {\n      await sleep(2000);\n    } else {\n      dispatch(response);\n      break;\n    }\n  }\n}\n\nasync function fetchInit(httpUrl: string): Promise<Action | \"retry\"> {\n  try {\n    const body = JSON.stringify({ split: SPLIT });\n    const response = await fetch(\n      new Request(httpUrl + \"/init\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body,\n      })\n    );\n    const data = await response.json();\n    if (!(\"clusterUrl\" in data) || !(\"programId\" in data)) {\n      throw new Error(\"Received invalid response\");\n    }\n\n    return {\n      url: httpUrl,\n      type: ActionType.Initialize,\n      config: configFromInit(data),\n    };\n  } catch (err) {\n    reportError(err, \"/init failed\");\n    return \"retry\";\n  }\n}\n\nasync function fetchAccounts(\n  httpUrl: string,\n  paymentAccount: Account | undefined\n): Promise<Action | \"retry\"> {\n  type RefreshData = {\n    split?: number;\n    paymentKey?: string;\n  };\n\n  const postData: RefreshData = {};\n  if (SPLIT) {\n    postData.split = SPLIT;\n  }\n  if (paymentAccount) {\n    postData.paymentKey = Buffer.from(paymentAccount.secretKey).toString(\n      \"base64\"\n    );\n  }\n\n  try {\n    const body = JSON.stringify(postData);\n    const response = await fetch(\n      new Request(httpUrl + \"/accounts\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body,\n      })\n    );\n\n    if (response.status === 400) {\n      return { type: ActionType.Failure, url: httpUrl, accounts: undefined };\n    } else if (response.status === 500) {\n      const error = await response.text();\n      throw new Error(error);\n    } else {\n      const data = await response.json();\n      if (\n        !(\"programAccounts\" in data) ||\n        !(\"feeAccounts\" in data) ||\n        !(\"accountCapacity\" in data)\n      ) {\n        throw new Error(\"Received invalid response\");\n      }\n\n      return { type: ActionType.Ready, url: httpUrl, accounts: configFromAccounts(data) };\n    }\n  } catch (err) {\n    reportError(err, \"/accounts failed\");\n    return \"retry\";\n  }\n}\n"]},"metadata":{},"sourceType":"module"}