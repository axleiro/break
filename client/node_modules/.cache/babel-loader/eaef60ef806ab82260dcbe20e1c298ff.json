{"ast":null,"code":"import { getMainCarrier } from '@sentry/hub';\nimport { registerErrorInstrumentation } from './errors';\nimport { IdleTransaction } from './idletransaction';\nimport { Transaction } from './transaction';\n/** Returns all trace headers that are currently on the top scope. */\n\nfunction traceHeaders() {\n  var scope = this.getScope();\n\n  if (scope) {\n    var span = scope.getSpan();\n\n    if (span) {\n      return {\n        'sentry-trace': span.toTraceparent()\n      };\n    }\n  }\n\n  return {};\n}\n/**\n * Use RNG to generate sampling decision, which all child spans inherit.\n */\n\n\nfunction sample(hub, transaction) {\n  var client = hub.getClient();\n\n  if (transaction.sampled === undefined) {\n    var sampleRate = client && client.getOptions().tracesSampleRate || 0; // if true = we want to have the transaction\n    // if false = we don't want to have it\n    // Math.random (inclusive of 0, but not 1)\n\n    transaction.sampled = Math.random() < sampleRate;\n  } // We only want to create a span list if we sampled the transaction\n  // If sampled == false, we will discard the span anyway, so we can save memory by not storing child spans\n\n\n  if (transaction.sampled) {\n    var experimentsOptions = client && client.getOptions()._experiments || {};\n    transaction.initSpanRecorder(experimentsOptions.maxSpans);\n  }\n\n  return transaction;\n}\n/**\n * {@see Hub.startTransaction}\n */\n\n\nfunction startTransaction(context) {\n  var transaction = new Transaction(context, this);\n  return sample(this, transaction);\n}\n/**\n * Create new idle transaction.\n */\n\n\nexport function startIdleTransaction(hub, context, idleTimeout, onScope) {\n  var transaction = new IdleTransaction(context, hub, idleTimeout, onScope);\n  return sample(hub, transaction);\n}\n/**\n * @private\n */\n\nexport function _addTracingExtensions() {\n  var carrier = getMainCarrier();\n\n  if (carrier.__SENTRY__) {\n    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n\n    if (!carrier.__SENTRY__.extensions.startTransaction) {\n      carrier.__SENTRY__.extensions.startTransaction = startTransaction;\n    }\n\n    if (!carrier.__SENTRY__.extensions.traceHeaders) {\n      carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;\n    }\n  }\n}\n/**\n * This patches the global object and injects the Tracing extensions methods\n */\n\nexport function addExtensionMethods() {\n  _addTracingExtensions(); // If an error happens globally, we should make sure transaction status is set to error.\n\n\n  registerErrorInstrumentation();\n}","map":{"version":3,"sources":["../src/hubextensions.ts"],"names":[],"mappings":"AAAA,SAAS,cAAT,QAAoC,aAApC;AAGA,SAAS,4BAAT,QAA6C,UAA7C;AACA,SAAS,eAAT,QAAgC,mBAAhC;AACA,SAAS,WAAT,QAA4B,eAA5B;AAEA;;AACA,SAAS,YAAT,GAAqB;AACnB,MAAM,KAAK,GAAG,KAAK,QAAL,EAAd;;AACA,MAAI,KAAJ,EAAW;AACT,QAAM,IAAI,GAAG,KAAK,CAAC,OAAN,EAAb;;AACA,QAAI,IAAJ,EAAU;AACR,aAAO;AACL,wBAAgB,IAAI,CAAC,aAAL;AADX,OAAP;AAGD;AACF;;AACD,SAAO,EAAP;AACD;AAED;;;;;AAGA,SAAS,MAAT,CAAuC,GAAvC,EAAiD,WAAjD,EAA+D;AAC7D,MAAM,MAAM,GAAG,GAAG,CAAC,SAAJ,EAAf;;AACA,MAAI,WAAW,CAAC,OAAZ,KAAwB,SAA5B,EAAuC;AACrC,QAAM,UAAU,GAAI,MAAM,IAAI,MAAM,CAAC,UAAP,GAAoB,gBAA/B,IAAoD,CAAvE,CADqC,CAErC;AACA;AACA;;AACA,IAAA,WAAW,CAAC,OAAZ,GAAsB,IAAI,CAAC,MAAL,KAAgB,UAAtC;AACD,GAR4D,CAU7D;AACA;;;AACA,MAAI,WAAW,CAAC,OAAhB,EAAyB;AACvB,QAAM,kBAAkB,GAAI,MAAM,IAAI,MAAM,CAAC,UAAP,GAAoB,YAA/B,IAAgD,EAA3E;AACA,IAAA,WAAW,CAAC,gBAAZ,CAA6B,kBAAkB,CAAC,QAAhD;AACD;;AAED,SAAO,WAAP;AACD;AAED;;;;;AAGA,SAAS,gBAAT,CAAqC,OAArC,EAAgE;AAC9D,MAAM,WAAW,GAAG,IAAI,WAAJ,CAAgB,OAAhB,EAAyB,IAAzB,CAApB;AACA,SAAO,MAAM,CAAC,IAAD,EAAO,WAAP,CAAb;AACD;AAED;;;;;AAGA,OAAM,SAAU,oBAAV,CACJ,GADI,EAEJ,OAFI,EAGJ,WAHI,EAIJ,OAJI,EAIa;AAEjB,MAAM,WAAW,GAAG,IAAI,eAAJ,CAAoB,OAApB,EAA6B,GAA7B,EAAkC,WAAlC,EAA+C,OAA/C,CAApB;AACA,SAAO,MAAM,CAAC,GAAD,EAAM,WAAN,CAAb;AACD;AAED;;;;AAGA,OAAM,SAAU,qBAAV,GAA+B;AACnC,MAAM,OAAO,GAAG,cAAc,EAA9B;;AACA,MAAI,OAAO,CAAC,UAAZ,EAAwB;AACtB,IAAA,OAAO,CAAC,UAAR,CAAmB,UAAnB,GAAgC,OAAO,CAAC,UAAR,CAAmB,UAAnB,IAAiC,EAAjE;;AACA,QAAI,CAAC,OAAO,CAAC,UAAR,CAAmB,UAAnB,CAA8B,gBAAnC,EAAqD;AACnD,MAAA,OAAO,CAAC,UAAR,CAAmB,UAAnB,CAA8B,gBAA9B,GAAiD,gBAAjD;AACD;;AACD,QAAI,CAAC,OAAO,CAAC,UAAR,CAAmB,UAAnB,CAA8B,YAAnC,EAAiD;AAC/C,MAAA,OAAO,CAAC,UAAR,CAAmB,UAAnB,CAA8B,YAA9B,GAA6C,YAA7C;AACD;AACF;AACF;AAED;;;;AAGA,OAAM,SAAU,mBAAV,GAA6B;AACjC,EAAA,qBAAqB,GADY,CAGjC;;;AACA,EAAA,4BAA4B;AAC7B","sourcesContent":["import { getMainCarrier, Hub } from '@sentry/hub';\nimport { TransactionContext } from '@sentry/types';\n\nimport { registerErrorInstrumentation } from './errors';\nimport { IdleTransaction } from './idletransaction';\nimport { Transaction } from './transaction';\n\n/** Returns all trace headers that are currently on the top scope. */\nfunction traceHeaders(this: Hub): { [key: string]: string } {\n  const scope = this.getScope();\n  if (scope) {\n    const span = scope.getSpan();\n    if (span) {\n      return {\n        'sentry-trace': span.toTraceparent(),\n      };\n    }\n  }\n  return {};\n}\n\n/**\n * Use RNG to generate sampling decision, which all child spans inherit.\n */\nfunction sample<T extends Transaction>(hub: Hub, transaction: T): T {\n  const client = hub.getClient();\n  if (transaction.sampled === undefined) {\n    const sampleRate = (client && client.getOptions().tracesSampleRate) || 0;\n    // if true = we want to have the transaction\n    // if false = we don't want to have it\n    // Math.random (inclusive of 0, but not 1)\n    transaction.sampled = Math.random() < sampleRate;\n  }\n\n  // We only want to create a span list if we sampled the transaction\n  // If sampled == false, we will discard the span anyway, so we can save memory by not storing child spans\n  if (transaction.sampled) {\n    const experimentsOptions = (client && client.getOptions()._experiments) || {};\n    transaction.initSpanRecorder(experimentsOptions.maxSpans as number);\n  }\n\n  return transaction;\n}\n\n/**\n * {@see Hub.startTransaction}\n */\nfunction startTransaction(this: Hub, context: TransactionContext): Transaction {\n  const transaction = new Transaction(context, this);\n  return sample(this, transaction);\n}\n\n/**\n * Create new idle transaction.\n */\nexport function startIdleTransaction(\n  hub: Hub,\n  context: TransactionContext,\n  idleTimeout?: number,\n  onScope?: boolean,\n): IdleTransaction {\n  const transaction = new IdleTransaction(context, hub, idleTimeout, onScope);\n  return sample(hub, transaction);\n}\n\n/**\n * @private\n */\nexport function _addTracingExtensions(): void {\n  const carrier = getMainCarrier();\n  if (carrier.__SENTRY__) {\n    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n    if (!carrier.__SENTRY__.extensions.startTransaction) {\n      carrier.__SENTRY__.extensions.startTransaction = startTransaction;\n    }\n    if (!carrier.__SENTRY__.extensions.traceHeaders) {\n      carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;\n    }\n  }\n}\n\n/**\n * This patches the global object and injects the Tracing extensions methods\n */\nexport function addExtensionMethods(): void {\n  _addTracingExtensions();\n\n  // If an error happens globally, we should make sure transaction status is set to error.\n  registerErrorInstrumentation();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}