{"ast":null,"code":"var _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/index.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$();\n\nimport * as React from \"react\";\nimport { useThrottle } from \"@react-hook/throttle\";\nimport { ConfirmedHelper, DEBUG_MODE } from \"./confirmed\";\nimport { TpsProvider, TpsContext } from \"./tps\";\nimport { CreateTxContext, CreateTxProvider } from \"./create\";\nimport { SelectedTxProvider } from \"./selected\";\nimport { useConnection } from \"providers/rpc\";\nimport { useSlotTiming } from \"providers/slot\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const COMMITMENT_PARAM = (() => {\n  const commitment = new URLSearchParams(window.location.search).get(\"commitment\");\n\n  switch (commitment) {\n    case \"recent\":\n      {\n        return commitment;\n      }\n\n    default:\n      {\n        return \"singleGossip\";\n      }\n  }\n})();\nexport const getCommitmentName = commitment => {\n  if (commitment === \"singleGossip\") {\n    return \"confirmed\";\n  } else {\n    return \"processed\";\n  }\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"new\":\n      {\n        const {\n          details,\n          pendingTransaction\n        } = action;\n        return [...state, {\n          details,\n          status: \"pending\",\n          received: [],\n          pending: pendingTransaction,\n          timing: {}\n        }];\n      }\n\n    case \"subscribed\":\n      {\n        const trackingId = action.trackingId;\n        if (trackingId >= state.length) return state;\n        const transaction = state[trackingId];\n        return state.map(tx => {\n          if (tx.details.signature === transaction.details.signature) {\n            if (tx.status !== \"timeout\") {\n              return { ...tx,\n                timing: { ...tx.timing,\n                  subscribed: action.timestamp\n                }\n              };\n            }\n          }\n\n          return tx;\n        });\n      }\n\n    case \"received\":\n      {\n        const trackingId = action.trackingId;\n        if (trackingId >= state.length) return state;\n        const transaction = state[trackingId];\n        return state.map(tx => {\n          if (tx.details.signature === transaction.details.signature) {\n            if (tx.status !== \"timeout\") {\n              return { ...tx,\n                received: [...tx.received, {\n                  slot: action.slot,\n                  timestamp: action.timestamp\n                }]\n              };\n            }\n          }\n\n          return tx;\n        });\n      }\n\n    case \"landed\":\n      {\n        return state.map(tx => {\n          if (tx.status === \"success\") {\n            const index = action.signatures.findIndex(val => val === tx.details.signature);\n\n            if (index >= 0) {\n              return { ...tx,\n                slot: { ...tx.slot,\n                  landed: action.slots[index]\n                }\n              };\n            }\n          }\n\n          return tx;\n        });\n      }\n\n    case \"track\":\n      {\n        const trackingId = action.trackingId;\n        if (trackingId >= state.length) return state;\n        const transaction = state[trackingId];\n        return state.map(tx => {\n          if (tx.details.signature === transaction.details.signature) {\n            if (tx.status === \"pending\") {\n              return {\n                status: \"success\",\n                details: tx.details,\n                received: tx.received,\n                slot: {\n                  target: tx.pending.targetSlot\n                },\n                timing: { ...tx.timing,\n                  [action.commitmentName]: action.timestamp\n                },\n                pending: tx.pending\n              };\n            } else if (tx.status === \"success\") {\n              return { ...tx,\n                timing: { ...tx.timing,\n                  [action.commitmentName]: action.timestamp\n                }\n              };\n            }\n          }\n\n          return tx;\n        });\n      }\n\n    case \"timeout\":\n      {\n        const trackingId = action.trackingId;\n        if (trackingId >= state.length) return state;\n        const timeout = state[trackingId];\n        if (timeout.status !== \"pending\") return state;\n        clearInterval(timeout.pending.retryId);\n        return state.map(tx => {\n          if (tx.details.signature === timeout.details.signature) {\n            return {\n              status: \"timeout\",\n              details: tx.details\n            };\n          } else {\n            return tx;\n          }\n        });\n      }\n\n    case \"update\":\n      {\n        const {\n          ids,\n          partition,\n          partitionCount\n        } = action.activeIdPartition;\n        return state.map((tx, trackingId) => {\n          if (trackingId % partitionCount !== partition) return tx;\n          const id = Math.floor(trackingId / partitionCount);\n\n          if (tx.status === \"pending\" && ids.has(id)) {\n            // Optimistically confirmed, no need to continue retry\n            if (action.commitment === \"singleGossip\") {\n              clearInterval(tx.pending.retryId);\n              clearTimeout(tx.pending.timeoutId);\n            }\n\n            const commitmentName = getCommitmentName(action.commitment);\n            return {\n              status: \"success\",\n              details: tx.details,\n              received: tx.received,\n              slot: {\n                target: tx.pending.targetSlot,\n                landed: action.estimatedSlot\n              },\n              timing: { ...tx.timing,\n                [commitmentName]: timeElapsed(tx.timing.subscribed, action.receivedAt)\n              },\n              pending: tx.pending\n            };\n          } else if (tx.status === \"success\") {\n            if (ids.has(id)) {\n              const commitmentName = getCommitmentName(action.commitment); // Already recorded conf time\n\n              if (tx.timing[commitmentName] !== undefined) {\n                return tx;\n              } // Optimistically confirmed, no need to continue retry\n\n\n              if (tx.pending && action.commitment === \"singleGossip\") {\n                clearInterval(tx.pending.retryId);\n                clearTimeout(tx.pending.timeoutId);\n              }\n\n              return { ...tx,\n                timing: { ...tx.timing,\n                  [commitmentName]: timeElapsed(tx.timing.subscribed, action.receivedAt)\n                }\n              };\n            } else if (action.commitment === \"recent\" && tx.pending && !ids.has(id)) {\n              // Don't revert to pending state if we already received timing info for other commitments\n              if (tx.timing[\"confirmed\"] !== undefined) {\n                return { ...tx,\n                  timing: { ...tx.timing,\n                    processed: undefined\n                  }\n                };\n              } // Revert to pending state because the previous notification likely came from a fork\n\n\n              return {\n                status: \"pending\",\n                details: tx.details,\n                received: tx.received,\n                pending: { ...tx.pending\n                },\n                timing: tx.timing\n              };\n            }\n          }\n\n          return tx;\n        });\n      }\n\n    case \"reset\":\n      {\n        state.forEach(tx => {\n          if (tx.status === \"pending\") {\n            clearTimeout(tx.pending.timeoutId);\n            clearInterval(tx.pending.retryId);\n          } else if (tx.status === \"success\" && tx.pending) {\n            clearTimeout(tx.pending.timeoutId);\n            clearInterval(tx.pending.retryId);\n          }\n        });\n        return [];\n      }\n\n    case \"root\":\n      {\n        const foundRooted = state.find(tx => {\n          if (tx.status === \"success\" && tx.pending) {\n            return tx.slot.landed === action.root;\n          } else {\n            return false;\n          }\n        }); // Avoid re-allocating state map\n\n        if (!foundRooted) return state;\n        return state.map(tx => {\n          if (tx.status === \"success\" && tx.pending) {\n            if (tx.slot.landed === action.root) {\n              clearInterval(tx.pending.retryId);\n              clearTimeout(tx.pending.timeoutId);\n              return { ...tx,\n                pending: undefined\n              };\n            }\n          }\n\n          return tx;\n        });\n      }\n  }\n}\n\nconst StateContext = /*#__PURE__*/React.createContext(undefined);\nconst DispatchContext = /*#__PURE__*/React.createContext(undefined);\nexport function TransactionsProvider({\n  children\n}) {\n  _s();\n\n  const [state, dispatch] = React.useReducer(reducer, []);\n  const connection = useConnection();\n  const stateRef = React.useRef(state);\n  React.useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n  React.useEffect(() => {\n    dispatch({\n      type: \"reset\"\n    });\n    if (connection === undefined) return;\n    const rootSubscription = connection.onRootChange(root => {\n      dispatch({\n        type: \"root\",\n        root\n      });\n    }); // Poll for signature statuses to determine which slot a tx landed in\n\n    const intervalId = DEBUG_MODE ? setInterval(async () => {\n      const fetchStatuses = [];\n      stateRef.current.forEach(tx => {\n        if (tx.status === \"success\" && tx.slot.landed === undefined) {\n          fetchStatuses.push(tx.details.signature);\n        }\n      });\n      if (fetchStatuses.length === 0) return;\n      const slots = [];\n      const signatures = [];\n      const statuses = (await connection.getSignatureStatuses(fetchStatuses)).value;\n\n      for (var i = 0; i < statuses.length; i++) {\n        const status = statuses[i];\n\n        if (status !== null) {\n          slots.push(status.slot);\n          signatures.push(fetchStatuses[i]);\n        }\n      }\n\n      if (slots.length === 0) return;\n      dispatch({\n        type: \"landed\",\n        slots,\n        signatures\n      });\n    }, 2000) : undefined;\n    return () => {\n      connection.removeRootChangeListener(rootSubscription);\n      intervalId !== undefined && clearInterval(intervalId);\n    };\n  }, [connection]);\n  const [throttledState, setThrottledState] = useThrottle(state, 10);\n  React.useEffect(() => {\n    setThrottledState(state);\n  }, [state, setThrottledState]);\n  return /*#__PURE__*/_jsxDEV(StateContext.Provider, {\n    value: throttledState,\n    children: /*#__PURE__*/_jsxDEV(DispatchContext.Provider, {\n      value: dispatch,\n      children: /*#__PURE__*/_jsxDEV(SelectedTxProvider, {\n        children: /*#__PURE__*/_jsxDEV(CreateTxProvider, {\n          children: /*#__PURE__*/_jsxDEV(ConfirmedHelper, {\n            children: /*#__PURE__*/_jsxDEV(TpsProvider, {\n              children: children\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 494,\n              columnNumber: 15\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 493,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 492,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 491,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 490,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 489,\n    columnNumber: 5\n  }, this);\n}\n\n_s(TransactionsProvider, \"CTftcQzjO65qV/w75vMO6HqqFto=\", false, function () {\n  return [useConnection, useThrottle];\n});\n\n_c = TransactionsProvider;\n\nfunction timeElapsed(sentAt, receivedAt) {\n  if (sentAt === undefined || receivedAt === undefined) return;\n  return parseFloat(((receivedAt - sentAt) / 1000).toFixed(3));\n}\n\nexport function useDispatch() {\n  _s2();\n\n  const dispatch = React.useContext(DispatchContext);\n\n  if (!dispatch) {\n    throw new Error(`useDispatch must be used within a TransactionsProvider`);\n  }\n\n  return dispatch;\n}\n\n_s2(useDispatch, \"kCU+r/6VuXUfg74P0SIOBSNFld8=\");\n\nexport function useTransactions() {\n  _s3();\n\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useTransactions must be used within a TransactionsProvider`);\n  }\n\n  return state;\n}\n\n_s3(useTransactions, \"kdLImxeHm3898p7tqgy8Fclg5s8=\");\n\nexport function useConfirmedCount() {\n  _s4();\n\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useConfirmedCount must be used within a TransactionsProvider`);\n  }\n\n  return state.filter(({\n    status\n  }) => status === \"success\").length;\n}\n\n_s4(useConfirmedCount, \"kdLImxeHm3898p7tqgy8Fclg5s8=\");\n\nexport function useDroppedCount() {\n  _s5();\n\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useDroppedCount must be used within a TransactionsProvider`);\n  }\n\n  return state.filter(({\n    status\n  }) => status === \"timeout\").length;\n}\n\n_s5(useDroppedCount, \"kdLImxeHm3898p7tqgy8Fclg5s8=\");\n\nexport function useAvgConfirmationTime() {\n  _s6();\n\n  const slotMetrics = useSlotTiming();\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useAvgConfirmationTime must be used within a TransactionsProvider`);\n  }\n\n  const confirmedTimes = state.reduce((confirmedTimes, tx) => {\n    if (tx.status === \"success\") {\n      const subscribed = tx.timing.subscribed;\n\n      if (subscribed !== undefined && tx.slot.landed !== undefined) {\n        const slotTiming = slotMetrics.current.get(tx.slot.landed);\n        const confirmed = slotTiming === null || slotTiming === void 0 ? void 0 : slotTiming.confirmed;\n        const confTime = timeElapsed(subscribed, confirmed);\n        if (confTime) confirmedTimes.push(confTime);\n      }\n    }\n\n    return confirmedTimes;\n  }, []);\n  const count = confirmedTimes.length;\n  if (count === 0) return 0;\n  const sum = confirmedTimes.reduce((sum, time) => sum + time, 0);\n  return sum / count;\n}\n\n_s6(useAvgConfirmationTime, \"VzeCgDeBCqkzg75uYd3dG462bWc=\", false, function () {\n  return [useSlotTiming];\n});\n\nexport function useCreatedCount() {\n  _s7();\n\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useCreatedCount must be used within a TransactionsProvider`);\n  }\n\n  return state.length;\n}\n\n_s7(useCreatedCount, \"kdLImxeHm3898p7tqgy8Fclg5s8=\");\n\nexport function useTps() {\n  _s8();\n\n  const tps = React.useContext(TpsContext);\n  if (tps === undefined) throw new Error(`useTps must be used within a TransactionsProvider`);\n  return tps;\n}\n\n_s8(useTps, \"um4YmFADYRtDWh7h95z2iPyy8yY=\");\n\nexport function useCreateTxRef() {\n  _s9();\n\n  const createTxRef = React.useContext(CreateTxContext);\n  if (createTxRef === undefined) throw new Error(`useCreateTxRef must be used within a TransactionsProvider`);\n  return createTxRef;\n}\n\n_s9(useCreateTxRef, \"Rf9hHOrtp3nEo8/2nyrvk4Uhlv8=\");\n\nvar _c;\n\n$RefreshReg$(_c, \"TransactionsProvider\");","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/index.tsx"],"names":["React","useThrottle","ConfirmedHelper","DEBUG_MODE","TpsProvider","TpsContext","CreateTxContext","CreateTxProvider","SelectedTxProvider","useConnection","useSlotTiming","COMMITMENT_PARAM","commitment","URLSearchParams","window","location","search","get","getCommitmentName","reducer","state","action","type","details","pendingTransaction","status","received","pending","timing","trackingId","length","transaction","map","tx","signature","subscribed","timestamp","slot","index","signatures","findIndex","val","landed","slots","target","targetSlot","commitmentName","timeout","clearInterval","retryId","ids","partition","partitionCount","activeIdPartition","id","Math","floor","has","clearTimeout","timeoutId","estimatedSlot","timeElapsed","receivedAt","undefined","processed","forEach","foundRooted","find","root","StateContext","createContext","DispatchContext","TransactionsProvider","children","dispatch","useReducer","connection","stateRef","useRef","useEffect","current","rootSubscription","onRootChange","intervalId","setInterval","fetchStatuses","push","statuses","getSignatureStatuses","value","i","removeRootChangeListener","throttledState","setThrottledState","sentAt","parseFloat","toFixed","useDispatch","useContext","Error","useTransactions","useConfirmedCount","filter","useDroppedCount","useAvgConfirmationTime","slotMetrics","confirmedTimes","reduce","slotTiming","confirmed","confTime","count","sum","time","useCreatedCount","useTps","tps","useCreateTxRef","createTxRef"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { useThrottle } from \"@react-hook/throttle\";\nimport { TransactionSignature, PublicKey } from \"@solana/web3.js\";\nimport { ConfirmedHelper, DEBUG_MODE } from \"./confirmed\";\nimport { TpsProvider, TpsContext } from \"./tps\";\nimport { CreateTxContext, CreateTxProvider } from \"./create\";\nimport { SelectedTxProvider } from \"./selected\";\nimport { useConnection } from \"providers/rpc\";\nimport { useSlotTiming } from \"providers/slot\";\n\nexport type ReceivedRecord = {\n  timestamp: number;\n  slot: number;\n};\n\nexport type PendingTransaction = {\n  targetSlot: number;\n  retryId?: number;\n  timeoutId?: number;\n};\n\nexport type TransactionDetails = {\n  id: number;\n  feeAccount: PublicKey;\n  programAccount: PublicKey;\n  signature: TransactionSignature;\n};\n\ntype Timing = {\n  subscribed?: number;\n  processed?: number;\n  confirmed?: number;\n};\n\ntype TimeoutState = {\n  status: \"timeout\";\n  details: TransactionDetails;\n};\n\ntype PendingState = {\n  status: \"pending\";\n  details: TransactionDetails;\n  received: Array<ReceivedRecord>;\n  pending: PendingTransaction;\n  timing: Timing;\n};\n\ntype SuccessState = {\n  status: \"success\";\n  details: TransactionDetails;\n  received: Array<ReceivedRecord>;\n  slot: {\n    target: number;\n    landed?: number;\n  };\n  timing: Timing;\n  pending?: PendingTransaction;\n};\n\nexport const COMMITMENT_PARAM = ((): TrackedCommitment => {\n  const commitment = new URLSearchParams(window.location.search).get(\n    \"commitment\"\n  );\n  switch (commitment) {\n    case \"recent\": {\n      return commitment;\n    }\n    default: {\n      return \"singleGossip\";\n    }\n  }\n})();\n\nexport const getCommitmentName = (\n  commitment: TrackedCommitment\n): CommitmentName => {\n  if (commitment === \"singleGossip\") {\n    return \"confirmed\";\n  } else {\n    return \"processed\";\n  }\n};\n\nexport type CommitmentName = \"processed\" | \"confirmed\";\n\nexport type TrackedCommitment = \"singleGossip\" | \"recent\";\n\nexport type TransactionStatus = \"success\" | \"timeout\" | \"pending\";\n\nexport type TransactionState = SuccessState | TimeoutState | PendingState;\n\ntype NewTransaction = {\n  type: \"new\";\n  trackingId: number;\n  details: TransactionDetails;\n  pendingTransaction: PendingTransaction;\n};\n\ntype UpdateIds = {\n  type: \"update\";\n  activeIdPartition: {\n    ids: Set<number>;\n    partition: number;\n    partitionCount: number;\n  };\n  commitment: TrackedCommitment;\n  receivedAt: number;\n  estimatedSlot: number;\n};\n\ntype TrackTransaction = {\n  type: \"track\";\n  commitmentName: CommitmentName;\n  trackingId: number;\n  slot: number;\n  timestamp: number;\n};\n\ntype TimeoutTransaction = {\n  type: \"timeout\";\n  trackingId: number;\n};\n\ntype ResetState = {\n  type: \"reset\";\n};\n\ntype RecordRoot = {\n  type: \"root\";\n  root: number;\n};\n\ntype SignatureReceived = {\n  type: \"received\";\n  timestamp: number;\n  trackingId: number;\n  slot: number;\n};\n\ntype SignatureSubscribed = {\n  type: \"subscribed\";\n  timestamp: number;\n  trackingId: number;\n  slot: number;\n};\n\ntype SignatureLanded = {\n  type: \"landed\";\n  signatures: TransactionSignature[];\n  slots: number[];\n};\n\ntype Action =\n  | NewTransaction\n  | UpdateIds\n  | TimeoutTransaction\n  | ResetState\n  | RecordRoot\n  | TrackTransaction\n  | SignatureReceived\n  | SignatureSubscribed\n  | SignatureLanded;\n\ntype State = TransactionState[];\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case \"new\": {\n      const { details, pendingTransaction } = action;\n      return [\n        ...state,\n        {\n          details,\n          status: \"pending\",\n          received: [],\n          pending: pendingTransaction,\n          timing: {},\n        },\n      ];\n    }\n\n    case \"subscribed\": {\n      const trackingId = action.trackingId;\n      if (trackingId >= state.length) return state;\n      const transaction = state[trackingId];\n      return state.map((tx) => {\n        if (tx.details.signature === transaction.details.signature) {\n          if (tx.status !== \"timeout\") {\n            return {\n              ...tx,\n              timing: {\n                ...tx.timing,\n                subscribed: action.timestamp,\n              },\n            };\n          }\n        }\n        return tx;\n      });\n    }\n\n    case \"received\": {\n      const trackingId = action.trackingId;\n      if (trackingId >= state.length) return state;\n      const transaction = state[trackingId];\n      return state.map((tx) => {\n        if (tx.details.signature === transaction.details.signature) {\n          if (tx.status !== \"timeout\") {\n            return {\n              ...tx,\n              received: [\n                ...tx.received,\n                {\n                  slot: action.slot,\n                  timestamp: action.timestamp,\n                },\n              ],\n            };\n          }\n        }\n        return tx;\n      });\n    }\n\n    case \"landed\": {\n        return state.map((tx) => {\n          if (tx.status === \"success\") {\n            const index = action.signatures.findIndex(\n              (val) => val === tx.details.signature\n            );\n            if (index >= 0) {\n              return {\n                ...tx,\n                slot: {\n                  ...tx.slot,\n                  landed: action.slots[index],\n                },\n              };\n            }\n          }\n          return tx;\n        });\n      }\n\n    case \"track\": {\n      const trackingId = action.trackingId;\n      if (trackingId >= state.length) return state;\n      const transaction = state[trackingId];\n\n      return state.map((tx) => {\n        if (tx.details.signature === transaction.details.signature) {\n          if (tx.status === \"pending\") {\n            return {\n              status: \"success\",\n              details: tx.details,\n              received: tx.received,\n              slot: {\n                target: tx.pending.targetSlot,\n              },\n              timing: {\n                ...tx.timing,\n                [action.commitmentName]: action.timestamp,\n              },\n              pending: tx.pending,\n            };\n          } else if (tx.status === \"success\") {\n            return {\n              ...tx,\n              timing: {\n                ...tx.timing,\n                [action.commitmentName]: action.timestamp,\n              },\n            };\n          }\n        }\n        return tx;\n      });\n    }\n\n    case \"timeout\": {\n      const trackingId = action.trackingId;\n      if (trackingId >= state.length) return state;\n      const timeout = state[trackingId];\n      if (timeout.status !== \"pending\") return state;\n      clearInterval(timeout.pending.retryId);\n\n      return state.map((tx) => {\n        if (tx.details.signature === timeout.details.signature) {\n          return {\n            status: \"timeout\",\n            details: tx.details,\n          };\n        } else {\n          return tx;\n        }\n      });\n    }\n\n    case \"update\": {\n      const { ids, partition, partitionCount } = action.activeIdPartition;\n      return state.map((tx, trackingId) => {\n        if (trackingId % partitionCount !== partition) return tx;\n        const id = Math.floor(trackingId / partitionCount);\n        if (tx.status === \"pending\" && ids.has(id)) {\n          // Optimistically confirmed, no need to continue retry\n          if (action.commitment === \"singleGossip\") {\n            clearInterval(tx.pending.retryId);\n            clearTimeout(tx.pending.timeoutId);\n          }\n\n          const commitmentName = getCommitmentName(action.commitment);\n          return {\n            status: \"success\",\n            details: tx.details,\n            received: tx.received,\n            slot: {\n              target: tx.pending.targetSlot,\n              landed: action.estimatedSlot,\n            },\n            timing: {\n              ...tx.timing,\n              [commitmentName]: timeElapsed(\n                tx.timing.subscribed,\n                action.receivedAt\n              ),\n            },\n            pending: tx.pending,\n          };\n        } else if (tx.status === \"success\") {\n          if (ids.has(id)) {\n            const commitmentName = getCommitmentName(action.commitment);\n            // Already recorded conf time\n            if (tx.timing[commitmentName] !== undefined) {\n              return tx;\n            }\n\n            // Optimistically confirmed, no need to continue retry\n            if (tx.pending && action.commitment === \"singleGossip\") {\n              clearInterval(tx.pending.retryId);\n              clearTimeout(tx.pending.timeoutId);\n            }\n\n            return {\n              ...tx,\n              timing: {\n                ...tx.timing,\n                [commitmentName]: timeElapsed(\n                  tx.timing.subscribed,\n                  action.receivedAt\n                ),\n              },\n            };\n          } else if (\n            action.commitment === \"recent\" &&\n            tx.pending &&\n            !ids.has(id)\n          ) {\n            // Don't revert to pending state if we already received timing info for other commitments\n            if (tx.timing[\"confirmed\"] !== undefined) {\n              return {\n                ...tx,\n                timing: {\n                  ...tx.timing,\n                  processed: undefined,\n                },\n              };\n            }\n\n            // Revert to pending state because the previous notification likely came from a fork\n            return {\n              status: \"pending\",\n              details: tx.details,\n              received: tx.received,\n              pending: { ...tx.pending },\n              timing: tx.timing,\n            };\n          }\n        }\n        return tx;\n      });\n    }\n\n    case \"reset\": {\n      state.forEach((tx) => {\n        if (tx.status === \"pending\") {\n          clearTimeout(tx.pending.timeoutId);\n          clearInterval(tx.pending.retryId);\n        } else if (tx.status === \"success\" && tx.pending) {\n          clearTimeout(tx.pending.timeoutId);\n          clearInterval(tx.pending.retryId);\n        }\n      });\n      return [];\n    }\n\n    case \"root\": {\n      const foundRooted = state.find((tx) => {\n        if (tx.status === \"success\" && tx.pending) {\n          return tx.slot.landed === action.root;\n        } else {\n          return false;\n        }\n      });\n\n      // Avoid re-allocating state map\n      if (!foundRooted) return state;\n\n      return state.map((tx) => {\n        if (tx.status === \"success\" && tx.pending) {\n          if (tx.slot.landed === action.root) {\n            clearInterval(tx.pending.retryId);\n            clearTimeout(tx.pending.timeoutId);\n            return {\n              ...tx,\n              pending: undefined,\n            };\n          }\n        }\n        return tx;\n      });\n    }\n  }\n}\n\nexport type Dispatch = (action: Action) => void;\nconst StateContext = React.createContext<State | undefined>(undefined);\nconst DispatchContext = React.createContext<Dispatch | undefined>(undefined);\n\ntype ProviderProps = { children: React.ReactNode };\nexport function TransactionsProvider({ children }: ProviderProps) {\n  const [state, dispatch] = React.useReducer(reducer, []);\n  const connection = useConnection();\n  const stateRef = React.useRef(state);\n\n  React.useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n\n  React.useEffect(() => {\n    dispatch({\n      type: \"reset\",\n    });\n\n    if (connection === undefined) return;\n    const rootSubscription = connection.onRootChange((root) => {\n      dispatch({ type: \"root\", root });\n    });\n\n    // Poll for signature statuses to determine which slot a tx landed in\n    const intervalId = DEBUG_MODE\n      ? setInterval(async () => {\n          const fetchStatuses: string[] = [];\n          stateRef.current.forEach((tx) => {\n            if (tx.status === \"success\" && tx.slot.landed === undefined) {\n              fetchStatuses.push(tx.details.signature);\n            }\n          });\n\n          if (fetchStatuses.length === 0) return;\n\n          const slots: number[] = [];\n          const signatures: TransactionSignature[] = [];\n          const statuses = (\n            await connection.getSignatureStatuses(fetchStatuses)\n          ).value;\n          for (var i = 0; i < statuses.length; i++) {\n            const status = statuses[i];\n            if (status !== null) {\n              slots.push(status.slot);\n              signatures.push(fetchStatuses[i]);\n            }\n          }\n          if (slots.length === 0) return;\n          dispatch({ type: \"landed\", slots, signatures });\n        }, 2000)\n      : undefined;\n\n    return () => {\n      connection.removeRootChangeListener(rootSubscription);\n      intervalId !== undefined && clearInterval(intervalId);\n    };\n  }, [connection]);\n\n  const [throttledState, setThrottledState] = useThrottle(state, 10);\n  React.useEffect(() => {\n    setThrottledState(state);\n  }, [state, setThrottledState]);\n\n  return (\n    <StateContext.Provider value={throttledState}>\n      <DispatchContext.Provider value={dispatch}>\n        <SelectedTxProvider>\n          <CreateTxProvider>\n            <ConfirmedHelper>\n              <TpsProvider>{children}</TpsProvider>\n            </ConfirmedHelper>\n          </CreateTxProvider>\n        </SelectedTxProvider>\n      </DispatchContext.Provider>\n    </StateContext.Provider>\n  );\n}\n\nfunction timeElapsed(\n  sentAt: number | undefined,\n  receivedAt: number | undefined\n): number | undefined {\n  if (sentAt === undefined || receivedAt === undefined) return;\n  return parseFloat(((receivedAt - sentAt) / 1000).toFixed(3));\n}\n\nexport function useDispatch() {\n  const dispatch = React.useContext(DispatchContext);\n  if (!dispatch) {\n    throw new Error(`useDispatch must be used within a TransactionsProvider`);\n  }\n\n  return dispatch;\n}\n\nexport function useTransactions() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useTransactions must be used within a TransactionsProvider`\n    );\n  }\n\n  return state;\n}\n\nexport function useConfirmedCount() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useConfirmedCount must be used within a TransactionsProvider`\n    );\n  }\n  return state.filter(({ status }) => status === \"success\").length;\n}\n\nexport function useDroppedCount() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useDroppedCount must be used within a TransactionsProvider`\n    );\n  }\n  return state.filter(({ status }) => status === \"timeout\").length;\n}\n\nexport function useAvgConfirmationTime() {\n  const slotMetrics = useSlotTiming();\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useAvgConfirmationTime must be used within a TransactionsProvider`\n    );\n  }\n\n  const confirmedTimes = state.reduce((confirmedTimes: number[], tx) => {\n    if (tx.status === \"success\") {\n      const subscribed = tx.timing.subscribed;\n      if (subscribed !== undefined && tx.slot.landed !== undefined) {\n        const slotTiming = slotMetrics.current.get(tx.slot.landed);\n        const confirmed = slotTiming?.confirmed;\n        const confTime = timeElapsed(subscribed, confirmed);\n        if (confTime) confirmedTimes.push(confTime);\n      }\n    }\n    return confirmedTimes;\n  }, []);\n\n  const count = confirmedTimes.length;\n  if (count === 0) return 0;\n  const sum = confirmedTimes.reduce((sum, time) => sum + time, 0);\n  return sum / count;\n}\n\nexport function useCreatedCount() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useCreatedCount must be used within a TransactionsProvider`\n    );\n  }\n  return state.length;\n}\n\nexport function useTps() {\n  const tps = React.useContext(TpsContext);\n  if (tps === undefined)\n    throw new Error(`useTps must be used within a TransactionsProvider`);\n  return tps;\n}\n\nexport function useCreateTxRef() {\n  const createTxRef = React.useContext(CreateTxContext);\n  if (createTxRef === undefined)\n    throw new Error(\n      `useCreateTxRef must be used within a TransactionsProvider`\n    );\n  return createTxRef;\n}\n"]},"metadata":{},"sourceType":"module"}