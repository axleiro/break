{"ast":null,"code":"var _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/blockhash.tsx\";\nimport * as React from \"react\";\nimport { useConnection } from \"./api\";\nimport { sleep, reportError } from \"utils\";\nconst POLL_INTERVAL_MS = 20000;\nexport let ActionType;\n\n(function (ActionType) {\n  ActionType[ActionType[\"Start\"] = 0] = \"Start\";\n  ActionType[ActionType[\"Stop\"] = 1] = \"Stop\";\n  ActionType[ActionType[\"Update\"] = 2] = \"Update\";\n})(ActionType || (ActionType = {}));\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case ActionType.Stop:\n      {\n        return {};\n      }\n\n    case ActionType.Update:\n      {\n        return Object.assign({}, state, {\n          blockhash: action.blockhash\n        });\n      }\n  }\n}\n\nconst StateContext = React.createContext(undefined);\nconst DispatchContext = React.createContext(undefined);\nexport function BlockhashProvider({\n  children\n}) {\n  const [state, dispatch] = React.useReducer(reducer, {});\n  const connection = useConnection();\n  const connectionRef = React.useRef(connection);\n  console.log(\"BLOCKHAHS\");\n  React.useEffect(() => {\n    if (connection === undefined) return;\n    connectionRef.current = connection;\n    refresh(dispatch, connectionRef);\n    const timerId = window.setInterval(() => refresh(dispatch, connectionRef), POLL_INTERVAL_MS);\n    return () => {\n      clearInterval(timerId);\n      dispatch({\n        type: ActionType.Stop\n      });\n    };\n  }, [connection]);\n  return /*#__PURE__*/React.createElement(StateContext.Provider, {\n    value: state,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(DispatchContext.Provider, {\n    value: dispatch,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 71,\n      columnNumber: 7\n    }\n  }, children));\n}\nexport function useBlockhash() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useBlockhash must be used within a BlockhashProvider`);\n  }\n\n  return state.blockhash;\n}\n\nasync function refresh(dispatch, connectionRef) {\n  let blockhash = undefined;\n  const connection = connectionRef.current;\n  if (connection === undefined) return;\n\n  while (blockhash === undefined && connection === connectionRef.current) {\n    try {\n      blockhash = (await connection.getRecentBlockhash(\"max\")).blockhash;\n      dispatch({\n        type: ActionType.Update,\n        blockhash\n      });\n    } catch (err) {\n      reportError(err, \"Failed to refresh blockhash\");\n      await sleep(1000);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/blockhash.tsx"],"names":["React","useConnection","sleep","reportError","POLL_INTERVAL_MS","ActionType","reducer","state","action","type","Stop","Update","Object","assign","blockhash","StateContext","createContext","undefined","DispatchContext","BlockhashProvider","children","dispatch","useReducer","connection","connectionRef","useRef","console","log","useEffect","current","refresh","timerId","window","setInterval","clearInterval","useBlockhash","useContext","Error","getRecentBlockhash","err"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { Blockhash, Connection } from \"@solana/web3.js\";\nimport { useConnection } from \"./api\";\nimport { sleep, reportError } from \"utils\";\n\nconst POLL_INTERVAL_MS = 20000;\n\nexport enum ActionType {\n  Start,\n  Stop,\n  Update,\n}\n\ninterface Stop {\n  type: ActionType.Stop;\n}\n\ninterface Update {\n  type: ActionType.Update;\n  blockhash: Blockhash;\n}\n\ninterface State {\n  blockhash?: Blockhash;\n}\n\ntype Action = Stop | Update;\ntype Dispatch = (action: Action) => void;\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case ActionType.Stop: {\n      return {};\n    }\n    case ActionType.Update: {\n      return Object.assign({}, state, {\n        blockhash: action.blockhash,\n      });\n    }\n  }\n}\n\nconst StateContext = React.createContext<State | undefined>(undefined);\nconst DispatchContext = React.createContext<Dispatch | undefined>(undefined);\n\ntype BlockhashProviderProps = { children: React.ReactNode };\nexport function BlockhashProvider({ children }: BlockhashProviderProps) {\n  const [state, dispatch] = React.useReducer(reducer, {});\n  const connection = useConnection();\n  const connectionRef = React.useRef(connection);\n  console.log(\"BLOCKHAHS\");\n\n  React.useEffect(() => {\n    if (connection === undefined) return;\n\n    connectionRef.current = connection;\n    refresh(dispatch, connectionRef);\n    const timerId = window.setInterval(\n      () => refresh(dispatch, connectionRef),\n      POLL_INTERVAL_MS\n    );\n\n    return () => {\n      clearInterval(timerId);\n      dispatch({ type: ActionType.Stop });\n    };\n  }, [connection]);\n\n  return (\n    <StateContext.Provider value={state}>\n      <DispatchContext.Provider value={dispatch}>\n        {children}\n      </DispatchContext.Provider>\n    </StateContext.Provider>\n  );\n}\n\nexport function useBlockhash() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(`useBlockhash must be used within a BlockhashProvider`);\n  }\n\n  return state.blockhash;\n}\n\nasync function refresh(\n  dispatch: Dispatch,\n  connectionRef: React.MutableRefObject<Connection | undefined>\n) {\n  let blockhash = undefined;\n  const connection = connectionRef.current;\n  if (connection === undefined) return;\n  while (blockhash === undefined && connection === connectionRef.current) {\n    try {\n      blockhash = (await connection.getRecentBlockhash(\"max\")).blockhash;\n      dispatch({ type: ActionType.Update, blockhash });\n    } catch (err) {\n      reportError(err, \"Failed to refresh blockhash\");\n      await sleep(1000);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}