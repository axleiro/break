{"ast":null,"code":"import { configFromInit, configFromAccounts } from \"./config\";\nimport { sleep, reportError } from \"utils\";\nimport { ConfigStatus } from \"./index\";\n\nconst SPLIT = (() => {\n  const split = parseInt(new URLSearchParams(window.location.search).get(\"split\") || \"\");\n\n  if (!isNaN(split)) {\n    return split;\n  }\n})();\n\nexport async function fetchWithRetry(dispatch, httpUrlRef, request) {\n  dispatch({\n    status: ConfigStatus.Fetching\n  });\n  const httpUrl = httpUrlRef.current;\n\n  while (httpUrl === httpUrlRef.current) {\n    let response;\n\n    switch (request.route) {\n      case \"accounts\":\n        {\n          response = await fetchAccounts(httpUrl, request.paymentAccount);\n          break;\n        }\n\n      case \"init\":\n        {\n          response = await fetchInit(httpUrl);\n        }\n    }\n\n    if (httpUrl !== httpUrlRef.current) break;\n\n    if (response === \"retry\") {\n      await sleep(2000);\n    } else {\n      dispatch(response);\n      break;\n    }\n  }\n}\n\nasync function fetchInit(httpUrl) {\n  try {\n    throw new Error(\"test\");\n    const body = JSON.stringify({\n      split: SPLIT\n    });\n    const response = await fetch(new Request(httpUrl + \"/init\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body\n    }));\n    const data = await response.json();\n\n    if (!(\"clusterUrl\" in data) || !(\"programId\" in data)) {\n      throw new Error(\"Received invalid response\");\n    }\n\n    return {\n      status: ConfigStatus.Initialized,\n      config: configFromInit(data)\n    };\n  } catch (err) {\n    reportError(err, \"/init failed\");\n    return \"retry\";\n  }\n}\n\nasync function fetchAccounts(httpUrl, paymentAccount) {\n  const postData = {};\n\n  if (SPLIT) {\n    postData.split = SPLIT;\n  }\n\n  if (paymentAccount) {\n    postData.paymentKey = Buffer.from(paymentAccount.secretKey).toString(\"base64\");\n  }\n\n  try {\n    const body = JSON.stringify(postData);\n    const response = await fetch(new Request(httpUrl + \"/accounts\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body\n    }));\n\n    if (response.status === 400) {\n      return {\n        status: ConfigStatus.Failure,\n        accounts: undefined\n      };\n    } else if (response.status === 500) {\n      const error = await response.text();\n      throw new Error(error);\n    } else {\n      const data = await response.json();\n\n      if (!(\"programAccounts\" in data) || !(\"feeAccounts\" in data) || !(\"accountCapacity\" in data)) {\n        throw new Error(\"Received invalid response\");\n      }\n\n      return {\n        status: ConfigStatus.Ready,\n        accounts: configFromAccounts(data)\n      };\n    }\n  } catch (err) {\n    reportError(err, \"/accounts failed\");\n    return \"retry\";\n  }\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/api/request.tsx"],"names":["configFromInit","configFromAccounts","sleep","reportError","ConfigStatus","SPLIT","split","parseInt","URLSearchParams","window","location","search","get","isNaN","fetchWithRetry","dispatch","httpUrlRef","request","status","Fetching","httpUrl","current","response","route","fetchAccounts","paymentAccount","fetchInit","Error","body","JSON","stringify","fetch","Request","method","headers","data","json","Initialized","config","err","postData","paymentKey","Buffer","from","secretKey","toString","Failure","accounts","undefined","error","text","Ready"],"mappings":"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","sourcesContent":["import { configFromInit, configFromAccounts } from \"./config\";\nimport { sleep, reportError } from \"utils\";\nimport { Action, Dispatch, ConfigStatus } from \"./index\";\nimport { Account } from \"@solana/web3.js\";\n\nconst SPLIT = ((): number | undefined => {\n  const split = parseInt(\n    new URLSearchParams(window.location.search).get(\"split\") || \"\"\n  );\n  if (!isNaN(split)) {\n    return split;\n  }\n})();\n\ntype InitRequest = {\n  route: \"init\";\n};\n\ntype AccountsRequest = {\n  route: \"accounts\";\n  paymentAccount: Account | undefined;\n};\n\ntype Request = AccountsRequest | InitRequest;\n\nexport async function fetchWithRetry(\n  dispatch: Dispatch,\n  httpUrlRef: React.MutableRefObject<string>,\n  request: Request\n) {\n  dispatch({\n    status: ConfigStatus.Fetching,\n  });\n\n  const httpUrl = httpUrlRef.current;\n  while (httpUrl === httpUrlRef.current) {\n    let response: Action | \"retry\";\n    switch (request.route) {\n      case \"accounts\": {\n        response = await fetchAccounts(httpUrl, request.paymentAccount);\n        break;\n      }\n      case \"init\": {\n        response = await fetchInit(httpUrl);\n      }\n    }\n\n    if (httpUrl !== httpUrlRef.current) break;\n    if (response === \"retry\") {\n      await sleep(2000);\n    } else {\n      dispatch(response);\n      break;\n    }\n  }\n}\n\nasync function fetchInit(httpUrl: string): Promise<Action | \"retry\"> {\n  try {\n    throw new Error(\"test\");\n    const body = JSON.stringify({ split: SPLIT });\n    const response = await fetch(\n      new Request(httpUrl + \"/init\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body,\n      })\n    );\n    const data = await response.json();\n    if (!(\"clusterUrl\" in data) || !(\"programId\" in data)) {\n      throw new Error(\"Received invalid response\");\n    }\n\n    return {\n      status: ConfigStatus.Initialized,\n      config: configFromInit(data),\n    };\n  } catch (err) {\n    reportError(err, \"/init failed\");\n    return \"retry\";\n  }\n}\n\nasync function fetchAccounts(\n  httpUrl: string,\n  paymentAccount: Account | undefined\n): Promise<Action | \"retry\"> {\n  type RefreshData = {\n    split?: number;\n    paymentKey?: string;\n  };\n\n  const postData: RefreshData = {};\n  if (SPLIT) {\n    postData.split = SPLIT;\n  }\n  if (paymentAccount) {\n    postData.paymentKey = Buffer.from(paymentAccount.secretKey).toString(\n      \"base64\"\n    );\n  }\n\n  try {\n    const body = JSON.stringify(postData);\n    const response = await fetch(\n      new Request(httpUrl + \"/accounts\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body,\n      })\n    );\n\n    if (response.status === 400) {\n      return { status: ConfigStatus.Failure, accounts: undefined };\n    } else if (response.status === 500) {\n      const error = await response.text();\n      throw new Error(error);\n    } else {\n      const data = await response.json();\n      if (\n        !(\"programAccounts\" in data) ||\n        !(\"feeAccounts\" in data) ||\n        !(\"accountCapacity\" in data)\n      ) {\n        throw new Error(\"Received invalid response\");\n      }\n\n      return { status: ConfigStatus.Ready, accounts: configFromAccounts(data) };\n    }\n  } catch (err) {\n    reportError(err, \"/accounts failed\");\n    return \"retry\";\n  }\n}\n"]},"metadata":{},"sourceType":"module"}