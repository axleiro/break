{"ast":null,"code":"var _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/create.tsx\";\nimport * as React from \"react\";\nimport { Transaction, TransactionInstruction } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport * as Bytes from \"utils/bytes\";\nimport { useTargetSlotRef, useDispatch } from \"./index\";\nimport { useConfig, useAccounts, useConnection } from \"providers/api\";\nimport { useBlockhash } from \"providers/blockhash\";\nimport { useSocket } from \"providers/socket\";\nimport { reportError } from \"utils\";\nconst SEND_TIMEOUT_MS = 45000;\nconst RETRY_INTERVAL_MS = 500;\nexport const CreateTxContext = React.createContext(undefined);\nexport function CreateTxProvider({\n  children\n}) {\n  const createTx = React.useRef(() => {});\n  const config = useConfig();\n  const accounts = useAccounts();\n  const idCounter = React.useRef(0);\n  const targetSlotRef = useTargetSlotRef();\n  const programDataAccount = accounts === null || accounts === void 0 ? void 0 : accounts.programAccounts[0].toBase58(); // Reset counter when program data accounts are refreshed\n\n  React.useEffect(() => {\n    idCounter.current = 0;\n  }, [programDataAccount]);\n  const connection = useConnection();\n  const blockhash = useBlockhash();\n  const dispatch = useDispatch();\n  const socket = useSocket();\n  React.useEffect(() => {\n    createTx.current = () => {\n      if (!connection || !blockhash || !socket || !config || !accounts || !targetSlotRef.current) return;\n      const id = idCounter.current;\n\n      if (id < accounts.accountCapacity * accounts.programAccounts.length) {\n        idCounter.current++;\n        createTransaction(connection, blockhash, targetSlotRef.current, config.programId, accounts, id, dispatch, socket);\n      } else {\n        reportError(new Error(\"Account capacity exceeded\"), \"failed to create transaction\");\n      }\n    };\n  }, [blockhash, connection, socket, config, accounts, dispatch, targetSlotRef]);\n  return /*#__PURE__*/React.createElement(CreateTxContext.Provider, {\n    value: createTx,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 83,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function createTransaction(connection, blockhash, targetSlot, programId, accounts, trackingId, dispatch, socket) {\n  const {\n    feeAccounts,\n    programAccounts\n  } = accounts;\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n  const instruction = new TransactionInstruction({\n    keys: [{\n      pubkey: programDataAccount,\n      isWritable: true,\n      isSigner: false\n    }],\n    programId,\n    data: Buffer.from(Bytes.instructionDataFromId(bitId))\n  });\n  const transaction = new Transaction();\n  transaction.add(instruction);\n  transaction.recentBlockhash = blockhash;\n  transaction.sign(feeAccount);\n  const serializedTx = transaction.serialize();\n  socket.send(serializedTx);\n  const sentAt = performance.now();\n  const pendingTransaction = {\n    sentAt,\n    targetSlot\n  };\n  pendingTransaction.timeoutId = window.setTimeout(() => {\n    dispatch({\n      type: \"timeout\",\n      trackingId\n    });\n  }, SEND_TIMEOUT_MS);\n  const signatureBuffer = transaction.signature;\n  if (!signatureBuffer) throw new Error(\"Failed to sign transaction\");\n  const signature = bs58.encode(signatureBuffer);\n  const details = {\n    id: bitId,\n    feeAccount: feeAccount.publicKey,\n    programAccount: programDataAccount,\n    signature\n  };\n  const retryUntil = new URLSearchParams(window.location.search).get(\"retry_until\");\n\n  if (retryUntil === null || retryUntil !== \"disabled\") {\n    pendingTransaction.retryId = window.setInterval(() => {\n      if (socket.readyState === WebSocket.OPEN) {\n        socket.send(serializedTx);\n      }\n    }, RETRY_INTERVAL_MS);\n  }\n\n  connection.onSignature(signature, (result, context) => {\n    dispatch({\n      type: \"signature\",\n      trackingId,\n      estimatedSlot: context.slot,\n      receivedAt: performance.now()\n    });\n  }, \"recent\");\n  dispatch({\n    type: \"new\",\n    details,\n    trackingId,\n    pendingTransaction\n  });\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/create.tsx"],"names":["React","Transaction","TransactionInstruction","bs58","Bytes","useTargetSlotRef","useDispatch","useConfig","useAccounts","useConnection","useBlockhash","useSocket","reportError","SEND_TIMEOUT_MS","RETRY_INTERVAL_MS","CreateTxContext","createContext","undefined","CreateTxProvider","children","createTx","useRef","config","accounts","idCounter","targetSlotRef","programDataAccount","programAccounts","toBase58","useEffect","current","connection","blockhash","dispatch","socket","id","accountCapacity","length","createTransaction","programId","Error","targetSlot","trackingId","feeAccounts","bitId","Math","floor","accountIndex","feeAccount","instruction","keys","pubkey","isWritable","isSigner","data","Buffer","from","instructionDataFromId","transaction","add","recentBlockhash","sign","serializedTx","serialize","send","sentAt","performance","now","pendingTransaction","timeoutId","window","setTimeout","type","signatureBuffer","signature","encode","details","publicKey","programAccount","retryUntil","URLSearchParams","location","search","get","retryId","setInterval","readyState","WebSocket","OPEN","onSignature","result","context","estimatedSlot","slot","receivedAt"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport {\n  Blockhash,\n  Transaction,\n  TransactionInstruction,\n  PublicKey,\n  Connection,\n} from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport * as Bytes from \"utils/bytes\";\nimport {\n  Dispatch,\n  PendingTransaction,\n  TransactionDetails,\n  useTargetSlotRef,\n  useDispatch,\n} from \"./index\";\nimport { AccountsConfig } from \"../api/config\";\nimport { useConfig, useAccounts, useConnection } from \"providers/api\";\nimport { useBlockhash } from \"providers/blockhash\";\nimport { useSocket } from \"providers/socket\";\nimport { reportError } from \"utils\";\n\nconst SEND_TIMEOUT_MS = 45000;\nconst RETRY_INTERVAL_MS = 500;\n\nexport const CreateTxContext = React.createContext<\n  React.MutableRefObject<() => void | undefined> | undefined\n>(undefined);\n\ntype ProviderProps = { children: React.ReactNode };\nexport function CreateTxProvider({ children }: ProviderProps) {\n  const createTx = React.useRef(() => {});\n  const config = useConfig();\n  const accounts = useAccounts();\n  const idCounter = React.useRef<number>(0);\n  const targetSlotRef = useTargetSlotRef();\n  const programDataAccount = accounts?.programAccounts[0].toBase58();\n\n  // Reset counter when program data accounts are refreshed\n  React.useEffect(() => {\n    idCounter.current = 0;\n  }, [programDataAccount]);\n\n  const connection = useConnection();\n  const blockhash = useBlockhash();\n  const dispatch = useDispatch();\n  const socket = useSocket();\n  React.useEffect(() => {\n    createTx.current = () => {\n      if (\n        !connection ||\n        !blockhash ||\n        !socket ||\n        !config ||\n        !accounts ||\n        !targetSlotRef.current\n      )\n        return;\n      const id = idCounter.current;\n      if (id < accounts.accountCapacity * accounts.programAccounts.length) {\n        idCounter.current++;\n        createTransaction(\n          connection,\n          blockhash,\n          targetSlotRef.current,\n          config.programId,\n          accounts,\n          id,\n          dispatch,\n          socket\n        );\n      } else {\n        reportError(\n          new Error(\"Account capacity exceeded\"),\n          \"failed to create transaction\"\n        );\n      }\n    };\n  }, [blockhash, connection, socket, config, accounts, dispatch, targetSlotRef]);\n\n  return (\n    <CreateTxContext.Provider value={createTx}>\n      {children}\n    </CreateTxContext.Provider>\n  );\n}\n\nexport function createTransaction(\n  connection: Connection,\n  blockhash: Blockhash,\n  targetSlot: number,\n  programId: PublicKey,\n  accounts: AccountsConfig,\n  trackingId: number,\n  dispatch: Dispatch,\n  socket: WebSocket\n) {\n  const { feeAccounts, programAccounts } = accounts;\n\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n  const instruction = new TransactionInstruction({\n    keys: [{ pubkey: programDataAccount, isWritable: true, isSigner: false }],\n    programId,\n    data: Buffer.from(Bytes.instructionDataFromId(bitId)),\n  });\n\n  const transaction = new Transaction();\n  transaction.add(instruction);\n  transaction.recentBlockhash = blockhash;\n  transaction.sign(feeAccount);\n  const serializedTx = transaction.serialize();\n  socket.send(serializedTx);\n  const sentAt = performance.now();\n\n  const pendingTransaction: PendingTransaction = { sentAt, targetSlot };\n  pendingTransaction.timeoutId = window.setTimeout(() => {\n    dispatch({ type: \"timeout\", trackingId });\n  }, SEND_TIMEOUT_MS);\n\n  const signatureBuffer = transaction.signature;\n  if (!signatureBuffer) throw new Error(\"Failed to sign transaction\");\n  const signature = bs58.encode(signatureBuffer);\n  const details: TransactionDetails = {\n    id: bitId,\n    feeAccount: feeAccount.publicKey,\n    programAccount: programDataAccount,\n    signature,\n  };\n\n  const retryUntil = new URLSearchParams(window.location.search).get(\n    \"retry_until\"\n  );\n  if (retryUntil === null || retryUntil !== \"disabled\") {\n    pendingTransaction.retryId = window.setInterval(() => {\n      if (socket.readyState === WebSocket.OPEN) {\n        socket.send(serializedTx);\n      }\n    }, RETRY_INTERVAL_MS);\n  }\n\n  connection.onSignature(signature, (result, context) => {\n    dispatch({\n      type: \"signature\",\n      trackingId,\n      estimatedSlot: context.slot,\n      receivedAt: performance.now(),\n    });\n  }, \"recent\");\n\n  dispatch({\n    type: \"new\",\n    details,\n    trackingId,\n    pendingTransaction,\n  });\n}\n"]},"metadata":{},"sourceType":"module"}