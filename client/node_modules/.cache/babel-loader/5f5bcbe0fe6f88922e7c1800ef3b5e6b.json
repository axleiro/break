{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { getGlobalObject, logger } from '@sentry/utils';\nimport { msToSec } from './utils';\nvar global = getGlobalObject();\n/** Class tracking metrics  */\n\nvar MetricsInstrumentation =\n/** @class */\nfunction () {\n  function MetricsInstrumentation() {\n    this._lcp = {};\n    this._performanceCursor = 0;\n\n    this._forceLCP = function () {\n      /* No-op, replaced later if LCP API is available. */\n      return;\n    };\n\n    if (global && global.performance) {\n      if (global.performance.mark) {\n        global.performance.mark('sentry-tracing-init');\n      }\n\n      this._trackLCP();\n    }\n  }\n  /** Add performance related spans to a transaction */\n\n\n  MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {\n    if (!global || !global.performance || !global.performance.getEntries) {\n      // Gatekeeper if performance API not available\n      return;\n    }\n\n    logger.log('[Tracing] Adding & adjusting spans using Performance API'); // TODO(fixme): depending on the 'op' directly is brittle.\n\n    if (transaction.op === 'pageload') {\n      // Force any pending records to be dispatched.\n      this._forceLCP();\n\n      if (this._lcp) {\n        // Set the last observed LCP score.\n        transaction.setData('_sentry_web_vitals', {\n          LCP: this._lcp\n        });\n      }\n    }\n\n    var timeOrigin = msToSec(performance.timeOrigin);\n    var entryScriptSrc;\n\n    if (global.document) {\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (var i = 0; i < document.scripts.length; i++) {\n        // We go through all scripts on the page and look for 'data-entry'\n        // We remember the name and measure the time between this script finished loading and\n        // our mark 'sentry-tracing-init'\n        if (document.scripts[i].dataset.entry === 'true') {\n          entryScriptSrc = document.scripts[i].src;\n          break;\n        }\n      }\n    }\n\n    var entryScriptStartTimestamp;\n    var tracingInitMarkStartTime;\n    global.performance.getEntries().slice(this._performanceCursor).forEach(function (entry) {\n      var startTime = msToSec(entry.startTime);\n      var duration = msToSec(entry.duration);\n\n      if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n        return;\n      }\n\n      switch (entry.entryType) {\n        case 'navigation':\n          addNavigationSpans(transaction, entry, timeOrigin);\n          break;\n\n        case 'mark':\n        case 'paint':\n        case 'measure':\n          {\n            var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n\n            if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {\n              tracingInitMarkStartTime = startTimestamp;\n            }\n\n            break;\n          }\n\n        case 'resource':\n          {\n            var resourceName = entry.name.replace(window.location.origin, '');\n            var endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin); // We remember the entry script end time to calculate the difference to the first init mark\n\n            if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {\n              entryScriptStartTimestamp = endTimestamp;\n            }\n\n            break;\n          }\n\n        default: // Ignore other entry types.\n\n      }\n    });\n\n    if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {\n      _startChild(transaction, {\n        description: 'evaluation',\n        endTimestamp: tracingInitMarkStartTime,\n        op: 'script',\n        startTimestamp: entryScriptStartTimestamp\n      });\n    }\n\n    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);\n  };\n  /** Starts tracking the Largest Contentful Paint on the current page. */\n\n\n  MetricsInstrumentation.prototype._trackLCP = function () {\n    var _this = this; // Based on reference implementation from https://web.dev/lcp/#measure-lcp-in-javascript.\n    // Use a try/catch instead of feature detecting `largest-contentful-paint`\n    // support, since some browsers throw when using the new `type` option.\n    // https://bugs.webkit.org/show_bug.cgi?id=209216\n\n\n    try {\n      // Keep track of whether (and when) the page was first hidden, see:\n      // https://github.com/w3c/page-visibility/issues/29\n      // NOTE: ideally this check would be performed in the document <head>\n      // to avoid cases where the visibility state changes before this code runs.\n      var firstHiddenTime_1 = document.visibilityState === 'hidden' ? 0 : Infinity;\n      document.addEventListener('visibilitychange', function (event) {\n        firstHiddenTime_1 = Math.min(firstHiddenTime_1, event.timeStamp);\n      }, {\n        once: true\n      });\n\n      var updateLCP_1 = function (entry) {\n        // Only include an LCP entry if the page wasn't hidden prior to\n        // the entry being dispatched. This typically happens when a page is\n        // loaded in a background tab.\n        if (entry.startTime < firstHiddenTime_1) {\n          // NOTE: the `startTime` value is a getter that returns the entry's\n          // `renderTime` value, if available, or its `loadTime` value otherwise.\n          // The `renderTime` value may not be available if the element is an image\n          // that's loaded cross-origin without the `Timing-Allow-Origin` header.\n          _this._lcp = __assign(__assign(__assign({}, entry.id && {\n            elementId: entry.id\n          }), entry.size && {\n            elementSize: entry.size\n          }), {\n            value: entry.startTime\n          });\n        }\n      }; // Create a PerformanceObserver that calls `updateLCP` for each entry.\n\n\n      var po_1 = new PerformanceObserver(function (entryList) {\n        entryList.getEntries().forEach(updateLCP_1);\n      }); // Observe entries of type `largest-contentful-paint`, including buffered entries,\n      // i.e. entries that occurred before calling `observe()` below.\n\n      po_1.observe({\n        buffered: true,\n        // @ts-ignore type does not exist on obj\n        type: 'largest-contentful-paint'\n      });\n\n      this._forceLCP = function () {\n        if (po_1.takeRecords) {\n          po_1.takeRecords().forEach(updateLCP_1);\n        }\n      };\n    } catch (e) {// Do nothing if the browser doesn't support this API.\n    }\n  };\n\n  return MetricsInstrumentation;\n}();\n\nexport { MetricsInstrumentation };\n/** Instrument navigation entries */\n\nfunction addNavigationSpans(transaction, entry, timeOrigin) {\n  addPerformanceNavigationTiming(transaction, entry, 'unloadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'domContentLoadedEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'loadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'connect', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin);\n  addRequest(transaction, entry, timeOrigin);\n}\n/** Create measure related spans */\n\n\nfunction addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {\n  var measureStartTimestamp = timeOrigin + startTime;\n  var measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType,\n    startTimestamp: measureStartTimestamp\n  });\n\n  return measureStartTimestamp;\n}\n/** Create resource related spans */\n\n\nexport function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return undefined;\n  }\n\n  var data = {};\n\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n\n  var startTimestamp = timeOrigin + startTime;\n  var endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp: endTimestamp,\n    op: entry.initiatorType ? \"resource.\" + entry.initiatorType : 'resource',\n    startTimestamp: startTimestamp,\n    data: data\n  });\n\n  return endTimestamp;\n}\n/** Create performance navigation related spans */\n\nfunction addPerformanceNavigationTiming(transaction, entry, event, timeOrigin) {\n  var end = entry[event + \"End\"];\n  var start = entry[event + \"Start\"];\n\n  if (!start || !end) {\n    return;\n  }\n\n  _startChild(transaction, {\n    description: event,\n    endTimestamp: timeOrigin + msToSec(end),\n    op: 'browser',\n    startTimestamp: timeOrigin + msToSec(start)\n  });\n}\n/** Create request and response related spans */\n\n\nfunction addRequest(transaction, entry, timeOrigin) {\n  _startChild(transaction, {\n    description: 'request',\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd),\n    op: 'browser',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart)\n  });\n\n  _startChild(transaction, {\n    description: 'response',\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd),\n    op: 'browser',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart)\n  });\n}\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\n\n\nexport function _startChild(transaction, _a) {\n  var startTimestamp = _a.startTimestamp,\n      ctx = __rest(_a, [\"startTimestamp\"]);\n\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild(__assign({\n    startTimestamp: startTimestamp\n  }, ctx));\n}","map":{"version":3,"sources":["../../src/browser/metrics.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { SpanContext } from '@sentry/types';\nimport { getGlobalObject, logger } from '@sentry/utils';\n\nimport { Span } from '../span';\nimport { Transaction } from '../transaction';\nimport { msToSec } from './utils';\n\nconst global = getGlobalObject<Window>();\n\n/** Class tracking metrics  */\nexport class MetricsInstrumentation {\n  private _lcp: Record<string, any> = {};\n\n  private _performanceCursor: number = 0;\n\n  public constructor() {\n    if (global && global.performance) {\n      if (global.performance.mark) {\n        global.performance.mark('sentry-tracing-init');\n      }\n\n      this._trackLCP();\n    }\n  }\n\n  /** Add performance related spans to a transaction */\n  public addPerformanceEntries(transaction: Transaction): void {\n    if (!global || !global.performance || !global.performance.getEntries) {\n      // Gatekeeper if performance API not available\n      return;\n    }\n\n    logger.log('[Tracing] Adding & adjusting spans using Performance API');\n\n    // TODO(fixme): depending on the 'op' directly is brittle.\n    if (transaction.op === 'pageload') {\n      // Force any pending records to be dispatched.\n      this._forceLCP();\n      if (this._lcp) {\n        // Set the last observed LCP score.\n        transaction.setData('_sentry_web_vitals', { LCP: this._lcp });\n      }\n    }\n\n    const timeOrigin = msToSec(performance.timeOrigin);\n    let entryScriptSrc: string | undefined;\n\n    if (global.document) {\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (let i = 0; i < document.scripts.length; i++) {\n        // We go through all scripts on the page and look for 'data-entry'\n        // We remember the name and measure the time between this script finished loading and\n        // our mark 'sentry-tracing-init'\n        if (document.scripts[i].dataset.entry === 'true') {\n          entryScriptSrc = document.scripts[i].src;\n          break;\n        }\n      }\n    }\n\n    let entryScriptStartTimestamp: number | undefined;\n    let tracingInitMarkStartTime: number | undefined;\n\n    global.performance\n      .getEntries()\n      .slice(this._performanceCursor)\n      .forEach((entry: Record<string, any>) => {\n        const startTime = msToSec(entry.startTime as number);\n        const duration = msToSec(entry.duration as number);\n\n        if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n          return;\n        }\n\n        switch (entry.entryType) {\n          case 'navigation':\n            addNavigationSpans(transaction, entry, timeOrigin);\n            break;\n          case 'mark':\n          case 'paint':\n          case 'measure': {\n            const startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n            if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {\n              tracingInitMarkStartTime = startTimestamp;\n            }\n            break;\n          }\n          case 'resource': {\n            const resourceName = (entry.name as string).replace(window.location.origin, '');\n            const endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n            // We remember the entry script end time to calculate the difference to the first init mark\n            if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {\n              entryScriptStartTimestamp = endTimestamp;\n            }\n            break;\n          }\n          default:\n          // Ignore other entry types.\n        }\n      });\n\n    if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {\n      _startChild(transaction, {\n        description: 'evaluation',\n        endTimestamp: tracingInitMarkStartTime,\n        op: 'script',\n        startTimestamp: entryScriptStartTimestamp,\n      });\n    }\n\n    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);\n  }\n\n  private _forceLCP: () => void = () => {\n    /* No-op, replaced later if LCP API is available. */\n    return;\n  };\n\n  /** Starts tracking the Largest Contentful Paint on the current page. */\n  private _trackLCP(): void {\n    // Based on reference implementation from https://web.dev/lcp/#measure-lcp-in-javascript.\n    // Use a try/catch instead of feature detecting `largest-contentful-paint`\n    // support, since some browsers throw when using the new `type` option.\n    // https://bugs.webkit.org/show_bug.cgi?id=209216\n    try {\n      // Keep track of whether (and when) the page was first hidden, see:\n      // https://github.com/w3c/page-visibility/issues/29\n      // NOTE: ideally this check would be performed in the document <head>\n      // to avoid cases where the visibility state changes before this code runs.\n      let firstHiddenTime = document.visibilityState === 'hidden' ? 0 : Infinity;\n      document.addEventListener(\n        'visibilitychange',\n        event => {\n          firstHiddenTime = Math.min(firstHiddenTime, event.timeStamp);\n        },\n        { once: true },\n      );\n\n      const updateLCP = (entry: PerformanceEntry): void => {\n        // Only include an LCP entry if the page wasn't hidden prior to\n        // the entry being dispatched. This typically happens when a page is\n        // loaded in a background tab.\n        if (entry.startTime < firstHiddenTime) {\n          // NOTE: the `startTime` value is a getter that returns the entry's\n          // `renderTime` value, if available, or its `loadTime` value otherwise.\n          // The `renderTime` value may not be available if the element is an image\n          // that's loaded cross-origin without the `Timing-Allow-Origin` header.\n          this._lcp = {\n            // @ts-ignore can't access id on entry\n            ...(entry.id && { elementId: entry.id }),\n            // @ts-ignore can't access id on entry\n            ...(entry.size && { elementSize: entry.size }),\n            value: entry.startTime,\n          };\n        }\n      };\n\n      // Create a PerformanceObserver that calls `updateLCP` for each entry.\n      const po = new PerformanceObserver(entryList => {\n        entryList.getEntries().forEach(updateLCP);\n      });\n\n      // Observe entries of type `largest-contentful-paint`, including buffered entries,\n      // i.e. entries that occurred before calling `observe()` below.\n      po.observe({\n        buffered: true,\n        // @ts-ignore type does not exist on obj\n        type: 'largest-contentful-paint',\n      });\n\n      this._forceLCP = () => {\n        if (po.takeRecords) {\n          po.takeRecords().forEach(updateLCP);\n        }\n      };\n    } catch (e) {\n      // Do nothing if the browser doesn't support this API.\n    }\n  }\n}\n\n/** Instrument navigation entries */\nfunction addNavigationSpans(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  addPerformanceNavigationTiming(transaction, entry, 'unloadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'domContentLoadedEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'loadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'connect', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin);\n  addRequest(transaction, entry, timeOrigin);\n}\n\n/** Create measure related spans */\nfunction addMeasureSpans(\n  transaction: Transaction,\n  entry: Record<string, any>,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): number {\n  const measureStartTimestamp = timeOrigin + startTime;\n  const measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name as string,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType as string,\n    startTimestamp: measureStartTimestamp,\n  });\n\n  return measureStartTimestamp;\n}\n\nexport interface ResourceEntry extends Record<string, unknown> {\n  initiatorType?: string;\n  transferSize?: number;\n  encodedBodySize?: number;\n  decodedBodySize?: number;\n}\n\n/** Create resource related spans */\nexport function addResourceSpans(\n  transaction: Transaction,\n  entry: ResourceEntry,\n  resourceName: string,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): number | undefined {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return undefined;\n  }\n\n  const data: Record<string, any> = {};\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp,\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource',\n    startTimestamp,\n    data,\n  });\n\n  return endTimestamp;\n}\n\n/** Create performance navigation related spans */\nfunction addPerformanceNavigationTiming(\n  transaction: Transaction,\n  entry: Record<string, any>,\n  event: string,\n  timeOrigin: number,\n): void {\n  const end = entry[`${event}End`] as number | undefined;\n  const start = entry[`${event}Start`] as number | undefined;\n  if (!start || !end) {\n    return;\n  }\n  _startChild(transaction, {\n    description: event,\n    endTimestamp: timeOrigin + msToSec(end),\n    op: 'browser',\n    startTimestamp: timeOrigin + msToSec(start),\n  });\n}\n\n/** Create request and response related spans */\nfunction addRequest(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  _startChild(transaction, {\n    description: 'request',\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n    op: 'browser',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart as number),\n  });\n\n  _startChild(transaction, {\n    description: 'response',\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n    op: 'browser',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart as number),\n  });\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nexport function _startChild(transaction: Transaction, { startTimestamp, ...ctx }: SpanContext): Span {\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild({\n    startTimestamp,\n    ...ctx,\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}