{"ast":null,"code":"// Program data is stored as little-endian\n// [0x1, 0x0] -> id #0, [0x0, 0x1] -> id #8\nexport function programDataToIds(bytes) {\n  const ids = new Array();\n  bytes.forEach((byte, i) => {\n    for (let j = 7; j >= 0; j--) {\n      if ((byte & 1 << j) === 1 << j) {\n        ids.push(8 * i + (7 - j));\n      }\n    }\n  });\n  return ids;\n} // Instruction data uses big-endian\n// id #0 -> [0x0, 0x0], id #256 -> [0x1, 0x0]\n\nconst MAX_ID = Math.pow(2, 16) - 1;\nexport function instructionDataFromId(id) {\n  if (id > MAX_ID || id < 0 || !Number.isInteger(id)) {\n    throw new Error(\"invalid id\");\n  }\n\n  const bytes = new Uint8Array(2);\n  bytes[0] = Math.floor(id / 256);\n  bytes[1] = id % 256;\n  return bytes;\n}\nexport function xor(a, b) {\n  if (a.length !== b.length) throw new Error(\"bytes are not the same length\");\n  const bytes = new Uint8Array(a);\n\n  for (let i = 0; i < b.length; i++) {\n    bytes[i] ^= b[i];\n  }\n\n  return bytes;\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/utils/bytes.ts"],"names":["programDataToIds","bytes","ids","Array","forEach","byte","i","j","push","MAX_ID","Math","pow","instructionDataFromId","id","Number","isInteger","Error","Uint8Array","floor","xor","a","b","length"],"mappings":"AAAA;AACA;AACA,OAAO,SAASA,gBAAT,CAA0BC,KAA1B,EAA4D;AACjE,QAAMC,GAAG,GAAG,IAAIC,KAAJ,EAAZ;AACAF,EAAAA,KAAK,CAACG,OAAN,CAAc,CAACC,IAAD,EAAOC,CAAP,KAAa;AACzB,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3B,UAAI,CAACF,IAAI,GAAI,KAAKE,CAAd,MAAsB,KAAKA,CAA/B,EAAkC;AAChCL,QAAAA,GAAG,CAACM,IAAJ,CAAS,IAAIF,CAAJ,IAAS,IAAIC,CAAb,CAAT;AACD;AACF;AACF,GAND;AAOA,SAAOL,GAAP;AACD,C,CAED;AACA;;AACA,MAAMO,MAAM,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAAjC;AACA,OAAO,SAASC,qBAAT,CAA+BC,EAA/B,EAAuD;AAC5D,MAAIA,EAAE,GAAGJ,MAAL,IAAeI,EAAE,GAAG,CAApB,IAAyB,CAACC,MAAM,CAACC,SAAP,CAAiBF,EAAjB,CAA9B,EAAoD;AAClD,UAAM,IAAIG,KAAJ,CAAU,YAAV,CAAN;AACD;;AAED,QAAMf,KAAK,GAAG,IAAIgB,UAAJ,CAAe,CAAf,CAAd;AACAhB,EAAAA,KAAK,CAAC,CAAD,CAAL,GAAWS,IAAI,CAACQ,KAAL,CAAWL,EAAE,GAAG,GAAhB,CAAX;AACAZ,EAAAA,KAAK,CAAC,CAAD,CAAL,GAAWY,EAAE,GAAG,GAAhB;AACA,SAAOZ,KAAP;AACD;AAED,OAAO,SAASkB,GAAT,CAAaC,CAAb,EAA4BC,CAA5B,EAAuD;AAC5D,MAAID,CAAC,CAACE,MAAF,KAAaD,CAAC,CAACC,MAAnB,EAA2B,MAAM,IAAIN,KAAJ,CAAU,+BAAV,CAAN;AAC3B,QAAMf,KAAK,GAAG,IAAIgB,UAAJ,CAAeG,CAAf,CAAd;;AACA,OAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGe,CAAC,CAACC,MAAtB,EAA8BhB,CAAC,EAA/B,EAAmC;AACjCL,IAAAA,KAAK,CAACK,CAAD,CAAL,IAAYe,CAAC,CAACf,CAAD,CAAb;AACD;;AACD,SAAOL,KAAP;AACD","sourcesContent":["// Program data is stored as little-endian\n// [0x1, 0x0] -> id #0, [0x0, 0x1] -> id #8\nexport function programDataToIds(bytes: Uint8Array): Array<number> {\n  const ids = new Array<number>();\n  bytes.forEach((byte, i) => {\n    for (let j = 7; j >= 0; j--) {\n      if ((byte & (1 << j)) === 1 << j) {\n        ids.push(8 * i + (7 - j));\n      }\n    }\n  });\n  return ids;\n}\n\n// Instruction data uses big-endian\n// id #0 -> [0x0, 0x0], id #256 -> [0x1, 0x0]\nconst MAX_ID = Math.pow(2, 16) - 1;\nexport function instructionDataFromId(id: number): Uint8Array {\n  if (id > MAX_ID || id < 0 || !Number.isInteger(id)) {\n    throw new Error(\"invalid id\");\n  }\n\n  const bytes = new Uint8Array(2);\n  bytes[0] = Math.floor(id / 256);\n  bytes[1] = id % 256;\n  return bytes;\n}\n\nexport function xor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  if (a.length !== b.length) throw new Error(\"bytes are not the same length\");\n  const bytes = new Uint8Array(a);\n  for (let i = 0; i < b.length; i++) {\n    bytes[i] ^= b[i];\n  }\n  return bytes;\n}\n"]},"metadata":{},"sourceType":"module"}