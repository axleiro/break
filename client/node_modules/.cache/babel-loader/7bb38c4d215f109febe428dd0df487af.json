{"ast":null,"code":"var _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/game.tsx\";\nimport React from \"react\";\nimport { useHistory, useRouteMatch, useLocation } from \"react-router-dom\";\nimport { useConfig, useRefreshAccounts, useAccounts, useIsFetching, useClearAccounts, useConnection } from \"providers/api\";\nimport { useDispatch } from \"providers/transactions\";\nimport { useWorkerState } from \"./worker\";\nimport { useBlockhash } from \"./blockhash\";\nexport const COUNTDOWN_SECS = 15;\nconst GameStateContext = React.createContext(undefined);\nconst CountdownContext = React.createContext(undefined);\nexport function GameStateProvider({\n  children\n}) {\n  const [countdown, setCountdown] = React.useState();\n  const [gameState, setGameState] = React.useState(\"loading\");\n  const resultsTimerRef = React.useRef();\n  const connection = useConnection();\n  const history = useHistory();\n  const location = useLocation();\n  const workerState = useWorkerState();\n  const config = useConfig();\n  const accounts = useAccounts();\n  const blockhash = useBlockhash();\n  const isResultsRoute = !!useRouteMatch(\"/results\");\n  const isGameRoute = !!useRouteMatch(\"/game\");\n  const isFetching = useIsFetching();\n  React.useEffect(() => {\n    setCountdown(undefined);\n  }, [isGameRoute, connection]);\n  React.useEffect(() => {\n    const paymentRequired = (config === null || config === void 0 ? void 0 : config.paymentRequired) === true;\n    const needsPayment = paymentRequired && !isFetching && !accounts;\n    const doneLoading = workerState === \"ready\" && config && (needsPayment || accounts);\n\n    if (!doneLoading) {\n      setGameState(\"loading\");\n    } else if (needsPayment) {\n      setGameState(\"payment\");\n    } else {\n      setGameState(gameState => {\n        if (gameState === \"loading\" || gameState === \"payment\") {\n          return isResultsRoute ? \"reset\" : \"play\";\n        }\n\n        return gameState;\n      });\n    }\n  }, [isResultsRoute, isFetching, workerState, config, accounts]);\n  React.useEffect(() => {\n    if (countdown !== undefined) {\n      if (!resultsTimerRef.current) {\n        resultsTimerRef.current = setTimeout(() => {\n          setGameState(\"reset\");\n          history.push({ ...location,\n            pathname: \"/results\"\n          });\n        }, COUNTDOWN_SECS * 1000);\n      }\n    } else if (resultsTimerRef.current) {\n      clearTimeout(resultsTimerRef.current);\n      resultsTimerRef.current = undefined;\n    }\n  }, [countdown, history, location]);\n  const countdownState = React.useMemo(() => {\n    return [countdown, setCountdown];\n  }, [countdown]);\n  return /*#__PURE__*/React.createElement(GameStateContext.Provider, {\n    value: gameState,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 84,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(CountdownContext.Provider, {\n    value: countdownState,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 7\n    }\n  }, children));\n}\nexport function useGameState() {\n  const context = React.useContext(GameStateContext);\n\n  if (!context) {\n    throw new Error(`useGameState must be used within a GameStateProvider`);\n  }\n\n  return context;\n}\nexport function useCountdown() {\n  const context = React.useContext(CountdownContext);\n\n  if (!context) {\n    throw new Error(`useCountdown must be used within a GameStateProvider`);\n  }\n\n  return context;\n}\nexport function useResetGame() {\n  var _useConfig;\n\n  const refreshAccounts = useRefreshAccounts();\n  const paymentRequired = (_useConfig = useConfig()) === null || _useConfig === void 0 ? void 0 : _useConfig.paymentRequired;\n  const clearAccounts = useClearAccounts();\n  const history = useHistory();\n  const location = useLocation();\n  const dispatch = useDispatch();\n  return React.useCallback(() => {\n    dispatch({\n      type: \"reset\"\n    });\n    history.push({ ...location,\n      pathname: \"/game\"\n    });\n\n    if (paymentRequired) {\n      clearAccounts();\n    } else {\n      refreshAccounts();\n    }\n  }, [refreshAccounts, paymentRequired, clearAccounts, history, location, dispatch]);\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/game.tsx"],"names":["React","useHistory","useRouteMatch","useLocation","useConfig","useRefreshAccounts","useAccounts","useIsFetching","useClearAccounts","useConnection","useDispatch","useWorkerState","useBlockhash","COUNTDOWN_SECS","GameStateContext","createContext","undefined","CountdownContext","GameStateProvider","children","countdown","setCountdown","useState","gameState","setGameState","resultsTimerRef","useRef","connection","history","location","workerState","config","accounts","blockhash","isResultsRoute","isGameRoute","isFetching","useEffect","paymentRequired","needsPayment","doneLoading","current","setTimeout","push","pathname","clearTimeout","countdownState","useMemo","useGameState","context","useContext","Error","useCountdown","useResetGame","refreshAccounts","clearAccounts","dispatch","useCallback","type"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,UAAT,EAAqBC,aAArB,EAAoCC,WAApC,QAAuD,kBAAvD;AACA,SACEC,SADF,EAEEC,kBAFF,EAGEC,WAHF,EAIEC,aAJF,EAKEC,gBALF,EAMEC,aANF,QAOO,eAPP;AAQA,SAASC,WAAT,QAA4B,wBAA5B;AACA,SAASC,cAAT,QAA+B,UAA/B;AACA,SAASC,YAAT,QAA6B,aAA7B;AAEA,OAAO,MAAMC,cAAc,GAAG,EAAvB;AAGP,MAAMC,gBAAgB,GAAGd,KAAK,CAACe,aAAN,CAA2CC,SAA3C,CAAzB;AAIA,MAAMC,gBAAgB,GAAGjB,KAAK,CAACe,aAAN,CACvBC,SADuB,CAAzB;AAKA,OAAO,SAASE,iBAAT,CAA2B;AAAEC,EAAAA;AAAF,CAA3B,EAAgD;AACrD,QAAM,CAACC,SAAD,EAAYC,YAAZ,IAA4BrB,KAAK,CAACsB,QAAN,EAAlC;AACA,QAAM,CAACC,SAAD,EAAYC,YAAZ,IAA4BxB,KAAK,CAACsB,QAAN,CAA0B,SAA1B,CAAlC;AACA,QAAMG,eAAe,GAAGzB,KAAK,CAAC0B,MAAN,EAAxB;AACA,QAAMC,UAAU,GAAGlB,aAAa,EAAhC;AACA,QAAMmB,OAAO,GAAG3B,UAAU,EAA1B;AACA,QAAM4B,QAAQ,GAAG1B,WAAW,EAA5B;AACA,QAAM2B,WAAW,GAAGnB,cAAc,EAAlC;AACA,QAAMoB,MAAM,GAAG3B,SAAS,EAAxB;AACA,QAAM4B,QAAQ,GAAG1B,WAAW,EAA5B;AACA,QAAM2B,SAAS,GAAGrB,YAAY,EAA9B;AACA,QAAMsB,cAAc,GAAG,CAAC,CAAChC,aAAa,CAAC,UAAD,CAAtC;AACA,QAAMiC,WAAW,GAAG,CAAC,CAACjC,aAAa,CAAC,OAAD,CAAnC;AACA,QAAMkC,UAAU,GAAG7B,aAAa,EAAhC;AAEAP,EAAAA,KAAK,CAACqC,SAAN,CAAgB,MAAM;AACpBhB,IAAAA,YAAY,CAACL,SAAD,CAAZ;AACD,GAFD,EAEG,CAACmB,WAAD,EAAcR,UAAd,CAFH;AAIA3B,EAAAA,KAAK,CAACqC,SAAN,CAAgB,MAAM;AACpB,UAAMC,eAAe,GAAG,CAAAP,MAAM,SAAN,IAAAA,MAAM,WAAN,YAAAA,MAAM,CAAEO,eAAR,MAA4B,IAApD;AACA,UAAMC,YAAY,GAAGD,eAAe,IAAI,CAACF,UAApB,IAAkC,CAACJ,QAAxD;AACA,UAAMQ,WAAW,GACfV,WAAW,KAAK,OAAhB,IAA2BC,MAA3B,KAAsCQ,YAAY,IAAIP,QAAtD,CADF;;AAEA,QAAI,CAACQ,WAAL,EAAkB;AAChBhB,MAAAA,YAAY,CAAC,SAAD,CAAZ;AACD,KAFD,MAEO,IAAIe,YAAJ,EAAkB;AACvBf,MAAAA,YAAY,CAAC,SAAD,CAAZ;AACD,KAFM,MAEA;AACLA,MAAAA,YAAY,CAAED,SAAD,IAAe;AAC1B,YAAIA,SAAS,KAAK,SAAd,IAA2BA,SAAS,KAAK,SAA7C,EAAwD;AACtD,iBAAOW,cAAc,GAAG,OAAH,GAAa,MAAlC;AACD;;AACD,eAAOX,SAAP;AACD,OALW,CAAZ;AAMD;AACF,GAjBD,EAiBG,CAACW,cAAD,EAAiBE,UAAjB,EAA6BN,WAA7B,EAA0CC,MAA1C,EAAkDC,QAAlD,CAjBH;AAmBAhC,EAAAA,KAAK,CAACqC,SAAN,CAAgB,MAAM;AACpB,QAAIjB,SAAS,KAAKJ,SAAlB,EAA6B;AAC3B,UAAI,CAACS,eAAe,CAACgB,OAArB,EAA8B;AAC5BhB,QAAAA,eAAe,CAACgB,OAAhB,GAA0BC,UAAU,CAAC,MAAM;AACzClB,UAAAA,YAAY,CAAC,OAAD,CAAZ;AACAI,UAAAA,OAAO,CAACe,IAAR,CAAa,EAAE,GAAGd,QAAL;AAAee,YAAAA,QAAQ,EAAE;AAAzB,WAAb;AACD,SAHmC,EAGjC/B,cAAc,GAAG,IAHgB,CAApC;AAID;AACF,KAPD,MAOO,IAAIY,eAAe,CAACgB,OAApB,EAA6B;AAClCI,MAAAA,YAAY,CAACpB,eAAe,CAACgB,OAAjB,CAAZ;AACAhB,MAAAA,eAAe,CAACgB,OAAhB,GAA0BzB,SAA1B;AACD;AACF,GAZD,EAYG,CAACI,SAAD,EAAYQ,OAAZ,EAAqBC,QAArB,CAZH;AAcA,QAAMiB,cAA8B,GAAG9C,KAAK,CAAC+C,OAAN,CAAc,MAAM;AACzD,WAAO,CAAC3B,SAAD,EAAYC,YAAZ,CAAP;AACD,GAFsC,EAEpC,CAACD,SAAD,CAFoC,CAAvC;AAIA,sBACE,oBAAC,gBAAD,CAAkB,QAAlB;AAA2B,IAAA,KAAK,EAAEG,SAAlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE,oBAAC,gBAAD,CAAkB,QAAlB;AAA2B,IAAA,KAAK,EAAEuB,cAAlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACG3B,QADH,CADF,CADF;AAOD;AAED,OAAO,SAAS6B,YAAT,GAAwB;AAC7B,QAAMC,OAAO,GAAGjD,KAAK,CAACkD,UAAN,CAAiBpC,gBAAjB,CAAhB;;AACA,MAAI,CAACmC,OAAL,EAAc;AACZ,UAAM,IAAIE,KAAJ,CAAW,sDAAX,CAAN;AACD;;AACD,SAAOF,OAAP;AACD;AAED,OAAO,SAASG,YAAT,GAAwB;AAC7B,QAAMH,OAAO,GAAGjD,KAAK,CAACkD,UAAN,CAAiBjC,gBAAjB,CAAhB;;AACA,MAAI,CAACgC,OAAL,EAAc;AACZ,UAAM,IAAIE,KAAJ,CAAW,sDAAX,CAAN;AACD;;AACD,SAAOF,OAAP;AACD;AAED,OAAO,SAASI,YAAT,GAAwB;AAAA;;AAC7B,QAAMC,eAAe,GAAGjD,kBAAkB,EAA1C;AACA,QAAMiC,eAAe,iBAAGlC,SAAS,EAAZ,+CAAG,WAAakC,eAArC;AACA,QAAMiB,aAAa,GAAG/C,gBAAgB,EAAtC;AACA,QAAMoB,OAAO,GAAG3B,UAAU,EAA1B;AACA,QAAM4B,QAAQ,GAAG1B,WAAW,EAA5B;AACA,QAAMqD,QAAQ,GAAG9C,WAAW,EAA5B;AAEA,SAAOV,KAAK,CAACyD,WAAN,CAAkB,MAAM;AAC7BD,IAAAA,QAAQ,CAAC;AAAEE,MAAAA,IAAI,EAAE;AAAR,KAAD,CAAR;AACA9B,IAAAA,OAAO,CAACe,IAAR,CAAa,EAAE,GAAGd,QAAL;AAAee,MAAAA,QAAQ,EAAE;AAAzB,KAAb;;AACA,QAAIN,eAAJ,EAAqB;AACnBiB,MAAAA,aAAa;AACd,KAFD,MAEO;AACLD,MAAAA,eAAe;AAChB;AACF,GARM,EAQJ,CACDA,eADC,EAEDhB,eAFC,EAGDiB,aAHC,EAID3B,OAJC,EAKDC,QALC,EAMD2B,QANC,CARI,CAAP;AAgBD","sourcesContent":["import React from \"react\";\nimport { useHistory, useRouteMatch, useLocation } from \"react-router-dom\";\nimport {\n  useConfig,\n  useRefreshAccounts,\n  useAccounts,\n  useIsFetching,\n  useClearAccounts,\n  useConnection,\n} from \"providers/api\";\nimport { useDispatch } from \"providers/transactions\";\nimport { useWorkerState } from \"./worker\";\nimport { useBlockhash } from \"./blockhash\";\n\nexport const COUNTDOWN_SECS = 15;\n\ntype GameState = \"loading\" | \"payment\" | \"play\" | \"reset\";\nconst GameStateContext = React.createContext<GameState | undefined>(undefined);\n\ntype SetCountdown = React.Dispatch<React.SetStateAction<number | undefined>>;\ntype CountdownState = [number | undefined, SetCountdown];\nconst CountdownContext = React.createContext<CountdownState | undefined>(\n  undefined\n);\n\ntype Props = { children: React.ReactNode };\nexport function GameStateProvider({ children }: Props) {\n  const [countdown, setCountdown] = React.useState<number>();\n  const [gameState, setGameState] = React.useState<GameState>(\"loading\");\n  const resultsTimerRef = React.useRef<NodeJS.Timer>();\n  const connection = useConnection();\n  const history = useHistory();\n  const location = useLocation();\n  const workerState = useWorkerState();\n  const config = useConfig();\n  const accounts = useAccounts();\n  const blockhash = useBlockhash();\n  const isResultsRoute = !!useRouteMatch(\"/results\");\n  const isGameRoute = !!useRouteMatch(\"/game\");\n  const isFetching = useIsFetching();\n\n  React.useEffect(() => {\n    setCountdown(undefined);\n  }, [isGameRoute, connection]);\n\n  React.useEffect(() => {\n    const paymentRequired = config?.paymentRequired === true;\n    const needsPayment = paymentRequired && !isFetching && !accounts;\n    const doneLoading =\n      workerState === \"ready\" && config && (needsPayment || accounts);\n    if (!doneLoading) {\n      setGameState(\"loading\");\n    } else if (needsPayment) {\n      setGameState(\"payment\");\n    } else {\n      setGameState((gameState) => {\n        if (gameState === \"loading\" || gameState === \"payment\") {\n          return isResultsRoute ? \"reset\" : \"play\";\n        }\n        return gameState;\n      });\n    }\n  }, [isResultsRoute, isFetching, workerState, config, accounts]);\n\n  React.useEffect(() => {\n    if (countdown !== undefined) {\n      if (!resultsTimerRef.current) {\n        resultsTimerRef.current = setTimeout(() => {\n          setGameState(\"reset\");\n          history.push({ ...location, pathname: \"/results\" });\n        }, COUNTDOWN_SECS * 1000);\n      }\n    } else if (resultsTimerRef.current) {\n      clearTimeout(resultsTimerRef.current);\n      resultsTimerRef.current = undefined;\n    }\n  }, [countdown, history, location]);\n\n  const countdownState: CountdownState = React.useMemo(() => {\n    return [countdown, setCountdown];\n  }, [countdown]);\n\n  return (\n    <GameStateContext.Provider value={gameState}>\n      <CountdownContext.Provider value={countdownState}>\n        {children}\n      </CountdownContext.Provider>\n    </GameStateContext.Provider>\n  );\n}\n\nexport function useGameState() {\n  const context = React.useContext(GameStateContext);\n  if (!context) {\n    throw new Error(`useGameState must be used within a GameStateProvider`);\n  }\n  return context;\n}\n\nexport function useCountdown() {\n  const context = React.useContext(CountdownContext);\n  if (!context) {\n    throw new Error(`useCountdown must be used within a GameStateProvider`);\n  }\n  return context;\n}\n\nexport function useResetGame() {\n  const refreshAccounts = useRefreshAccounts();\n  const paymentRequired = useConfig()?.paymentRequired;\n  const clearAccounts = useClearAccounts();\n  const history = useHistory();\n  const location = useLocation();\n  const dispatch = useDispatch();\n\n  return React.useCallback(() => {\n    dispatch({ type: \"reset\" });\n    history.push({ ...location, pathname: \"/game\" });\n    if (paymentRequired) {\n      clearAccounts();\n    } else {\n      refreshAccounts();\n    }\n  }, [\n    refreshAccounts,\n    paymentRequired,\n    clearAccounts,\n    history,\n    location,\n    dispatch,\n  ]);\n}\n"]},"metadata":{},"sourceType":"module"}