{"ast":null,"code":"import*as React from\"react\";import bs58 from\"bs58\";import{getCommitmentName,useDispatch}from\"./index\";import{CreateTransactionRPC}from\"../../workers/create-transaction-rpc\";import{useConfig,useAccounts}from\"providers/server/http\";import{useBlockhash}from\"providers/rpc/blockhash\";import{useSocket}from\"providers/server/socket\";import{reportError}from\"utils\";import{useConnection}from\"providers/rpc\";import{DEBUG_MODE,subscribedCommitments}from\"./confirmed\";import{useTargetSlotRef}from\"providers/slot\";import{jsx as _jsx}from\"react/jsx-runtime\";var SEND_TIMEOUT_MS=45000;var RETRY_INTERVAL_MS=500;var workerRPC=new CreateTransactionRPC();export var CreateTxContext=/*#__PURE__*/React.createContext(undefined);export function CreateTxProvider(_ref){var children=_ref.children;var createTx=React.useRef(function(){});var config=useConfig();var accounts=useAccounts();var idCounter=React.useRef(0);var targetSlotRef=useTargetSlotRef();var programDataAccount=accounts===null||accounts===void 0?void 0:accounts.programAccounts[0].toBase58();// Reset counter when program data accounts are refreshed\nReact.useEffect(function(){idCounter.current=0;},[programDataAccount]);var connection=useConnection();var blockhash=useBlockhash();var dispatch=useDispatch();var socket=useSocket();React.useEffect(function(){createTx.current=function(){if(!connection||!blockhash||!socket||!config||!accounts||!targetSlotRef.current)return;var id=idCounter.current;if(id<accounts.accountCapacity*accounts.programAccounts.length){idCounter.current++;createTransaction(connection,blockhash,targetSlotRef.current,config.programId,accounts,id,dispatch,socket);}else{reportError(new Error(\"Account capacity exceeded\"),\"failed to create transaction\");}};},[blockhash,connection,socket,config,accounts,dispatch,targetSlotRef]);return/*#__PURE__*/_jsx(CreateTxContext.Provider,{value:createTx,children:children});}export function createTransaction(connection,blockhash,targetSlot,programId,accounts,trackingId,dispatch,socket){var feeAccounts=accounts.feeAccounts,programAccounts=accounts.programAccounts;var bitId=Math.floor(trackingId/feeAccounts.length);var accountIndex=trackingId%feeAccounts.length;var programDataAccount=programAccounts[accountIndex];var feeAccount=feeAccounts[accountIndex];workerRPC.createTransaction({trackingId:trackingId,blockhash:blockhash,programId:programId.toBase58(),programDataAccount:programDataAccount.toBase58(),bitId:bitId,feeAccountSecretKey:feeAccount.secretKey}).then(function(response){var signature=response.signature,serializedTransaction=response.serializedTransaction;socket.send(serializedTransaction);var pendingTransaction={targetSlot:targetSlot};pendingTransaction.timeoutId=window.setTimeout(function(){dispatch({type:\"timeout\",trackingId:trackingId});},SEND_TIMEOUT_MS);var encodedSignature=bs58.encode(signature);var details={id:bitId,feeAccount:feeAccount.publicKey,programAccount:programDataAccount,signature:encodedSignature};dispatch({type:\"new\",details:details,trackingId:trackingId,pendingTransaction:pendingTransaction});if(DEBUG_MODE){connection.onTransaction(encodedSignature,function(notification,context){if(notification.type===\"subscribedSignature\"){dispatch({type:\"subscribed\",timestamp:notification.timestamp,trackingId:trackingId,slot:context.slot});}else if(notification.type===\"receivedSignature\"){console.log(encodedSignature,notification,context);dispatch({type:\"received\",timestamp:notification.timestamp,trackingId:trackingId,slot:context.slot});}},{commitment:\"max\",enableReceivedNotification:true});var commitments=subscribedCommitments();commitments.forEach(function(commitment){connection.onTransaction(encodedSignature,function(notification,context){if(notification.type===\"processedSignature\"){var commitmentName=getCommitmentName(commitment);dispatch({type:\"track\",commitmentName:commitmentName,trackingId:trackingId,slot:context.slot,timestamp:notification.timestamp});}},{commitment:commitment});});}var retry=new URLSearchParams(window.location.search).get(\"retry\");if(retry===null||retry!==\"disabled\"){pendingTransaction.retryId=window.setInterval(function(){if(socket.readyState===WebSocket.OPEN){socket.send(serializedTransaction);}},RETRY_INTERVAL_MS);}},function(error){console.error(error);});}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/create.tsx"],"names":["React","bs58","getCommitmentName","useDispatch","CreateTransactionRPC","useConfig","useAccounts","useBlockhash","useSocket","reportError","useConnection","DEBUG_MODE","subscribedCommitments","useTargetSlotRef","SEND_TIMEOUT_MS","RETRY_INTERVAL_MS","workerRPC","CreateTxContext","createContext","undefined","CreateTxProvider","children","createTx","useRef","config","accounts","idCounter","targetSlotRef","programDataAccount","programAccounts","toBase58","useEffect","current","connection","blockhash","dispatch","socket","id","accountCapacity","length","createTransaction","programId","Error","targetSlot","trackingId","feeAccounts","bitId","Math","floor","accountIndex","feeAccount","feeAccountSecretKey","secretKey","then","response","signature","serializedTransaction","send","pendingTransaction","timeoutId","window","setTimeout","type","encodedSignature","encode","details","publicKey","programAccount","onTransaction","notification","context","timestamp","slot","console","log","commitment","enableReceivedNotification","commitments","forEach","commitmentName","retry","URLSearchParams","location","search","get","retryId","setInterval","readyState","WebSocket","OPEN","error"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { Blockhash, PublicKey, Connection } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport {\n  Dispatch,\n  getCommitmentName,\n  PendingTransaction,\n  TransactionDetails,\n  useDispatch,\n} from \"./index\";\nimport { AccountsConfig } from \"../server/http/config\";\nimport {\n  CreateTransactionRPC,\n  CreateTransactionResponseMessage,\n} from \"../../workers/create-transaction-rpc\";\nimport { useConfig, useAccounts } from \"providers/server/http\";\nimport { useBlockhash } from \"providers/rpc/blockhash\";\nimport { useSocket } from \"providers/server/socket\";\nimport { reportError } from \"utils\";\nimport { useConnection } from \"providers/rpc\";\nimport { DEBUG_MODE, subscribedCommitments } from \"./confirmed\";\nimport { useTargetSlotRef } from \"providers/slot\";\n\nconst SEND_TIMEOUT_MS = 45000;\nconst RETRY_INTERVAL_MS = 500;\n\nconst workerRPC = new CreateTransactionRPC();\nexport const CreateTxContext = React.createContext<\n  React.MutableRefObject<() => void | undefined> | undefined\n>(undefined);\n\ntype ProviderProps = { children: React.ReactNode };\nexport function CreateTxProvider({ children }: ProviderProps) {\n  const createTx = React.useRef(() => {});\n  const config = useConfig();\n  const accounts = useAccounts();\n  const idCounter = React.useRef<number>(0);\n  const targetSlotRef = useTargetSlotRef();\n  const programDataAccount = accounts?.programAccounts[0].toBase58();\n\n  // Reset counter when program data accounts are refreshed\n  React.useEffect(() => {\n    idCounter.current = 0;\n  }, [programDataAccount]);\n\n  const connection = useConnection();\n  const blockhash = useBlockhash();\n  const dispatch = useDispatch();\n  const socket = useSocket();\n  React.useEffect(() => {\n    createTx.current = () => {\n      if (\n        !connection ||\n        !blockhash ||\n        !socket ||\n        !config ||\n        !accounts ||\n        !targetSlotRef.current\n      )\n        return;\n      const id = idCounter.current;\n      if (id < accounts.accountCapacity * accounts.programAccounts.length) {\n        idCounter.current++;\n        createTransaction(\n          connection,\n          blockhash,\n          targetSlotRef.current,\n          config.programId,\n          accounts,\n          id,\n          dispatch,\n          socket\n        );\n      } else {\n        reportError(\n          new Error(\"Account capacity exceeded\"),\n          \"failed to create transaction\"\n        );\n      }\n    };\n  }, [\n    blockhash,\n    connection,\n    socket,\n    config,\n    accounts,\n    dispatch,\n    targetSlotRef,\n  ]);\n\n  return (\n    <CreateTxContext.Provider value={createTx}>\n      {children}\n    </CreateTxContext.Provider>\n  );\n}\n\nexport function createTransaction(\n  connection: Connection,\n  blockhash: Blockhash,\n  targetSlot: number,\n  programId: PublicKey,\n  accounts: AccountsConfig,\n  trackingId: number,\n  dispatch: Dispatch,\n  socket: WebSocket\n) {\n  const { feeAccounts, programAccounts } = accounts;\n\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n\n  workerRPC\n    .createTransaction({\n      trackingId: trackingId,\n      blockhash: blockhash,\n      programId: programId.toBase58(),\n      programDataAccount: programDataAccount.toBase58(),\n      bitId: bitId,\n      feeAccountSecretKey: feeAccount.secretKey,\n    })\n    .then(\n      (response: CreateTransactionResponseMessage) => {\n        const { signature, serializedTransaction } = response;\n\n        socket.send(serializedTransaction);\n\n        const pendingTransaction: PendingTransaction = { targetSlot };\n        pendingTransaction.timeoutId = window.setTimeout(() => {\n          dispatch({ type: \"timeout\", trackingId });\n        }, SEND_TIMEOUT_MS);\n\n        const encodedSignature = bs58.encode(signature);\n        const details: TransactionDetails = {\n          id: bitId,\n          feeAccount: feeAccount.publicKey,\n          programAccount: programDataAccount,\n          signature: encodedSignature,\n        };\n\n        dispatch({\n          type: \"new\",\n          details,\n          trackingId,\n          pendingTransaction,\n        });\n\n        if (DEBUG_MODE) {\n          (connection as any).onTransaction(\n            encodedSignature,\n            (notification: any, context: any) => {\n              if (notification.type === \"subscribedSignature\") {\n                dispatch({\n                  type: \"subscribed\",\n                  timestamp: notification.timestamp,\n                  trackingId,\n                  slot: context.slot,\n                });\n              } else if (notification.type === \"receivedSignature\") {\n                console.log(encodedSignature, notification, context);\n                dispatch({\n                  type: \"received\",\n                  timestamp: notification.timestamp,\n                  trackingId,\n                  slot: context.slot,\n                });\n              }\n            },\n            {\n              commitment: \"max\",\n              enableReceivedNotification: true,\n            }\n          );\n\n          const commitments = subscribedCommitments();\n          commitments.forEach((commitment) => {\n            (connection as any).onTransaction(\n              encodedSignature,\n              (notification: any, context: any) => {\n                if (notification.type === \"processedSignature\") {\n                  const commitmentName = getCommitmentName(commitment);\n                  dispatch({\n                    type: \"track\",\n                    commitmentName,\n                    trackingId,\n                    slot: context.slot,\n                    timestamp: notification.timestamp,\n                  });\n                }\n              },\n              { commitment }\n            );\n          });\n        }\n\n        const retry = new URLSearchParams(window.location.search).get(\"retry\");\n        if (retry === null || retry !== \"disabled\") {\n          pendingTransaction.retryId = window.setInterval(() => {\n            if (socket.readyState === WebSocket.OPEN) {\n              socket.send(serializedTransaction);\n            }\n          }, RETRY_INTERVAL_MS);\n        }\n      },\n      (error: any) => {\n        console.error(error);\n      }\n    );\n}\n"]},"metadata":{},"sourceType":"module"}