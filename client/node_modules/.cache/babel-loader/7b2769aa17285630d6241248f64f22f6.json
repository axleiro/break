{"ast":null,"code":"// Program data is stored as little-endian\n// [0x1, 0x0] -> id #0, [0x0, 0x1] -> id #8\nexport function programDataToIds(bytes){var ids=new Array();bytes.forEach(function(byte,i){for(var j=7;j>=0;j--){if((byte&1<<j)===1<<j){ids.push(8*i+(7-j));}}});return ids;}// Instruction data uses big-endian\n// id #0 -> [0x0, 0x0], id #256 -> [0x1, 0x0]\nvar MAX_ID=Math.pow(2,16)-1;export function instructionDataFromId(id){if(id>MAX_ID||id<0||!Number.isInteger(id)){throw new Error(\"invalid id\");}var bytes=new Uint8Array(2);bytes[0]=Math.floor(id/256);bytes[1]=id%256;return bytes;}export function xor(a,b){if(a.length!==b.length)throw new Error(\"bytes are not the same length\");var bytes=new Uint8Array(a);for(var i=0;i<b.length;i++){bytes[i]^=b[i];}return bytes;}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/utils/bytes.ts"],"names":["programDataToIds","bytes","ids","Array","forEach","byte","i","j","push","MAX_ID","Math","pow","instructionDataFromId","id","Number","isInteger","Error","Uint8Array","floor","xor","a","b","length"],"mappings":"AAAA;AACA;AACA,MAAO,SAASA,CAAAA,gBAAT,CAA0BC,KAA1B,CAA4D,CACjE,GAAMC,CAAAA,GAAG,CAAG,GAAIC,CAAAA,KAAJ,EAAZ,CACAF,KAAK,CAACG,OAAN,CAAc,SAACC,IAAD,CAAOC,CAAP,CAAa,CACzB,IAAK,GAAIC,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,EAAI,CAArB,CAAwBA,CAAC,EAAzB,CAA6B,CAC3B,GAAI,CAACF,IAAI,CAAI,GAAKE,CAAd,IAAsB,GAAKA,CAA/B,CAAkC,CAChCL,GAAG,CAACM,IAAJ,CAAS,EAAIF,CAAJ,EAAS,EAAIC,CAAb,CAAT,EACD,CACF,CACF,CAND,EAOA,MAAOL,CAAAA,GAAP,CACD,CAED;AACA;AACA,GAAMO,CAAAA,MAAM,CAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,CAAY,EAAZ,EAAkB,CAAjC,CACA,MAAO,SAASC,CAAAA,qBAAT,CAA+BC,EAA/B,CAAuD,CAC5D,GAAIA,EAAE,CAAGJ,MAAL,EAAeI,EAAE,CAAG,CAApB,EAAyB,CAACC,MAAM,CAACC,SAAP,CAAiBF,EAAjB,CAA9B,CAAoD,CAClD,KAAM,IAAIG,CAAAA,KAAJ,CAAU,YAAV,CAAN,CACD,CAED,GAAMf,CAAAA,KAAK,CAAG,GAAIgB,CAAAA,UAAJ,CAAe,CAAf,CAAd,CACAhB,KAAK,CAAC,CAAD,CAAL,CAAWS,IAAI,CAACQ,KAAL,CAAWL,EAAE,CAAG,GAAhB,CAAX,CACAZ,KAAK,CAAC,CAAD,CAAL,CAAWY,EAAE,CAAG,GAAhB,CACA,MAAOZ,CAAAA,KAAP,CACD,CAED,MAAO,SAASkB,CAAAA,GAAT,CAAaC,CAAb,CAA4BC,CAA5B,CAAuD,CAC5D,GAAID,CAAC,CAACE,MAAF,GAAaD,CAAC,CAACC,MAAnB,CAA2B,KAAM,IAAIN,CAAAA,KAAJ,CAAU,+BAAV,CAAN,CAC3B,GAAMf,CAAAA,KAAK,CAAG,GAAIgB,CAAAA,UAAJ,CAAeG,CAAf,CAAd,CACA,IAAK,GAAId,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGe,CAAC,CAACC,MAAtB,CAA8BhB,CAAC,EAA/B,CAAmC,CACjCL,KAAK,CAACK,CAAD,CAAL,EAAYe,CAAC,CAACf,CAAD,CAAb,CACD,CACD,MAAOL,CAAAA,KAAP,CACD","sourcesContent":["// Program data is stored as little-endian\n// [0x1, 0x0] -> id #0, [0x0, 0x1] -> id #8\nexport function programDataToIds(bytes: Uint8Array): Array<number> {\n  const ids = new Array<number>();\n  bytes.forEach((byte, i) => {\n    for (let j = 7; j >= 0; j--) {\n      if ((byte & (1 << j)) === 1 << j) {\n        ids.push(8 * i + (7 - j));\n      }\n    }\n  });\n  return ids;\n}\n\n// Instruction data uses big-endian\n// id #0 -> [0x0, 0x0], id #256 -> [0x1, 0x0]\nconst MAX_ID = Math.pow(2, 16) - 1;\nexport function instructionDataFromId(id: number): Uint8Array {\n  if (id > MAX_ID || id < 0 || !Number.isInteger(id)) {\n    throw new Error(\"invalid id\");\n  }\n\n  const bytes = new Uint8Array(2);\n  bytes[0] = Math.floor(id / 256);\n  bytes[1] = id % 256;\n  return bytes;\n}\n\nexport function xor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  if (a.length !== b.length) throw new Error(\"bytes are not the same length\");\n  const bytes = new Uint8Array(a);\n  for (let i = 0; i < b.length; i++) {\n    bytes[i] ^= b[i];\n  }\n  return bytes;\n}\n"]},"metadata":{},"sourceType":"module"}