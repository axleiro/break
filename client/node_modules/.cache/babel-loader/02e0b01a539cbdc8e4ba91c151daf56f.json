{"ast":null,"code":"import { configFromInit, configFromAccounts } from \"./config\";\nimport { sleep, reportError } from \"utils\";\nimport { ActionType } from \"./index\";\n\nconst SPLIT = (() => {\n  const split = parseInt(new URLSearchParams(window.location.search).get(\"split\") || \"\");\n\n  if (!isNaN(split)) {\n    return split;\n  }\n})();\n\nexport async function fetchWithRetry(dispatch, httpUrlRef, request) {\n  switch (request.route) {\n    case \"accounts\":\n      {\n        dispatch({\n          type: ActionType.ClearAccounts,\n          url: httpUrlRef.current\n        });\n        break;\n      }\n\n    case \"init\":\n      {\n        dispatch({\n          type: ActionType.FetchInit,\n          url: httpUrlRef.current\n        });\n        break;\n      }\n  }\n\n  const httpUrl = httpUrlRef.current;\n\n  while (httpUrl === httpUrlRef.current) {\n    let response;\n\n    switch (request.route) {\n      case \"accounts\":\n        {\n          response = await fetchAccounts(httpUrl, request.paymentAccount);\n          break;\n        }\n\n      case \"init\":\n        {\n          response = await fetchInit(httpUrl);\n        }\n    }\n\n    if (httpUrl !== httpUrlRef.current) break;\n\n    if (response === \"retry\") {\n      await sleep(2000);\n    } else if (response !== undefined) {\n      dispatch(response);\n      break;\n    }\n  }\n}\n\nasync function fetchInit(httpUrl) {\n  try {\n    const body = JSON.stringify({\n      split: SPLIT\n    });\n    const response = await fetch(new Request(httpUrl + \"/init\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body\n    }));\n    const data = await response.json();\n\n    if (!(\"clusterUrl\" in data) || !(\"programId\" in data)) {\n      throw new Error(\"Received invalid response\");\n    }\n\n    return {\n      url: httpUrl,\n      type: ActionType.Initialize,\n      config: configFromInit(data)\n    };\n  } catch (err) {\n    reportError(err, \"/init failed\");\n    return \"retry\";\n  }\n}\n\nasync function fetchAccounts(httpUrl, paymentAccount) {\n  const postData = {};\n\n  if (SPLIT) {\n    postData.split = SPLIT;\n  }\n\n  if (paymentAccount) {\n    postData.paymentKey = Buffer.from(paymentAccount.secretKey).toString(\"base64\");\n  }\n\n  try {\n    const body = JSON.stringify(postData);\n    const response = await fetch(new Request(httpUrl + \"/accounts\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body\n    }));\n\n    if (response.status === 400) {\n      return;\n    } else if (response.status === 500) {\n      const error = await response.text();\n      throw new Error(error);\n    } else {\n      const data = await response.json();\n\n      if (!(\"programAccounts\" in data) || !(\"feeAccounts\" in data) || !(\"accountCapacity\" in data)) {\n        throw new Error(\"Received invalid response\");\n      }\n\n      return {\n        type: ActionType.Ready,\n        url: httpUrl,\n        accounts: configFromAccounts(data)\n      };\n    }\n  } catch (err) {\n    reportError(err, \"/accounts failed\");\n    return \"retry\";\n  }\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/api/request.tsx"],"names":["configFromInit","configFromAccounts","sleep","reportError","ActionType","SPLIT","split","parseInt","URLSearchParams","window","location","search","get","isNaN","fetchWithRetry","dispatch","httpUrlRef","request","route","type","ClearAccounts","url","current","FetchInit","httpUrl","response","fetchAccounts","paymentAccount","fetchInit","undefined","body","JSON","stringify","fetch","Request","method","headers","data","json","Error","Initialize","config","err","postData","paymentKey","Buffer","from","secretKey","toString","status","error","text","Ready","accounts"],"mappings":"AAAA,SAASA,cAAT,EAAyBC,kBAAzB,QAAmD,UAAnD;AACA,SAASC,KAAT,EAAgBC,WAAhB,QAAmC,OAAnC;AACA,SAA2BC,UAA3B,QAA6C,SAA7C;;AAGA,MAAMC,KAAK,GAAG,CAAC,MAA0B;AACvC,QAAMC,KAAK,GAAGC,QAAQ,CACpB,IAAIC,eAAJ,CAAoBC,MAAM,CAACC,QAAP,CAAgBC,MAApC,EAA4CC,GAA5C,CAAgD,OAAhD,KAA4D,EADxC,CAAtB;;AAGA,MAAI,CAACC,KAAK,CAACP,KAAD,CAAV,EAAmB;AACjB,WAAOA,KAAP;AACD;AACF,CAPa,GAAd;;AAoBA,OAAO,eAAeQ,cAAf,CACLC,QADK,EAELC,UAFK,EAGLC,OAHK,EAIL;AACA,UAAQA,OAAO,CAACC,KAAhB;AACE,SAAK,UAAL;AAAiB;AACfH,QAAAA,QAAQ,CAAC;AACPI,UAAAA,IAAI,EAAEf,UAAU,CAACgB,aADV;AAEPC,UAAAA,GAAG,EAAEL,UAAU,CAACM;AAFT,SAAD,CAAR;AAIA;AACD;;AACD,SAAK,MAAL;AAAa;AACXP,QAAAA,QAAQ,CAAC;AACPI,UAAAA,IAAI,EAAEf,UAAU,CAACmB,SADV;AAEPF,UAAAA,GAAG,EAAEL,UAAU,CAACM;AAFT,SAAD,CAAR;AAIA;AACD;AAdH;;AAiBA,QAAME,OAAO,GAAGR,UAAU,CAACM,OAA3B;;AACA,SAAOE,OAAO,KAAKR,UAAU,CAACM,OAA9B,EAAuC;AACrC,QAAIG,QAAJ;;AACA,YAAQR,OAAO,CAACC,KAAhB;AACE,WAAK,UAAL;AAAiB;AACfO,UAAAA,QAAQ,GAAG,MAAMC,aAAa,CAACF,OAAD,EAAUP,OAAO,CAACU,cAAlB,CAA9B;AACA;AACD;;AACD,WAAK,MAAL;AAAa;AACXF,UAAAA,QAAQ,GAAG,MAAMG,SAAS,CAACJ,OAAD,CAA1B;AACD;AAPH;;AAUA,QAAIA,OAAO,KAAKR,UAAU,CAACM,OAA3B,EAAoC;;AACpC,QAAIG,QAAQ,KAAK,OAAjB,EAA0B;AACxB,YAAMvB,KAAK,CAAC,IAAD,CAAX;AACD,KAFD,MAEO,IAAIuB,QAAQ,KAAKI,SAAjB,EAA4B;AACjCd,MAAAA,QAAQ,CAACU,QAAD,CAAR;AACA;AACD;AACF;AACF;;AAED,eAAeG,SAAf,CAAyBJ,OAAzB,EAAqE;AACnE,MAAI;AACF,UAAMM,IAAI,GAAGC,IAAI,CAACC,SAAL,CAAe;AAAE1B,MAAAA,KAAK,EAAED;AAAT,KAAf,CAAb;AACA,UAAMoB,QAAQ,GAAG,MAAMQ,KAAK,CAC1B,IAAIC,OAAJ,CAAYV,OAAO,GAAG,OAAtB,EAA+B;AAC7BW,MAAAA,MAAM,EAAE,MADqB;AAE7BC,MAAAA,OAAO,EAAE;AACP,wBAAgB;AADT,OAFoB;AAK7BN,MAAAA;AAL6B,KAA/B,CAD0B,CAA5B;AASA,UAAMO,IAAI,GAAG,MAAMZ,QAAQ,CAACa,IAAT,EAAnB;;AACA,QAAI,EAAE,gBAAgBD,IAAlB,KAA2B,EAAE,eAAeA,IAAjB,CAA/B,EAAuD;AACrD,YAAM,IAAIE,KAAJ,CAAU,2BAAV,CAAN;AACD;;AAED,WAAO;AACLlB,MAAAA,GAAG,EAAEG,OADA;AAELL,MAAAA,IAAI,EAAEf,UAAU,CAACoC,UAFZ;AAGLC,MAAAA,MAAM,EAAEzC,cAAc,CAACqC,IAAD;AAHjB,KAAP;AAKD,GArBD,CAqBE,OAAOK,GAAP,EAAY;AACZvC,IAAAA,WAAW,CAACuC,GAAD,EAAM,cAAN,CAAX;AACA,WAAO,OAAP;AACD;AACF;;AAED,eAAehB,aAAf,CACEF,OADF,EAEEG,cAFF,EAGyC;AAMvC,QAAMgB,QAAqB,GAAG,EAA9B;;AACA,MAAItC,KAAJ,EAAW;AACTsC,IAAAA,QAAQ,CAACrC,KAAT,GAAiBD,KAAjB;AACD;;AACD,MAAIsB,cAAJ,EAAoB;AAClBgB,IAAAA,QAAQ,CAACC,UAAT,GAAsBC,MAAM,CAACC,IAAP,CAAYnB,cAAc,CAACoB,SAA3B,EAAsCC,QAAtC,CACpB,QADoB,CAAtB;AAGD;;AAED,MAAI;AACF,UAAMlB,IAAI,GAAGC,IAAI,CAACC,SAAL,CAAeW,QAAf,CAAb;AACA,UAAMlB,QAAQ,GAAG,MAAMQ,KAAK,CAC1B,IAAIC,OAAJ,CAAYV,OAAO,GAAG,WAAtB,EAAmC;AACjCW,MAAAA,MAAM,EAAE,MADyB;AAEjCC,MAAAA,OAAO,EAAE;AACP,wBAAgB;AADT,OAFwB;AAKjCN,MAAAA;AALiC,KAAnC,CAD0B,CAA5B;;AAUA,QAAIL,QAAQ,CAACwB,MAAT,KAAoB,GAAxB,EAA6B;AAC3B;AACD,KAFD,MAEO,IAAIxB,QAAQ,CAACwB,MAAT,KAAoB,GAAxB,EAA6B;AAClC,YAAMC,KAAK,GAAG,MAAMzB,QAAQ,CAAC0B,IAAT,EAApB;AACA,YAAM,IAAIZ,KAAJ,CAAUW,KAAV,CAAN;AACD,KAHM,MAGA;AACL,YAAMb,IAAI,GAAG,MAAMZ,QAAQ,CAACa,IAAT,EAAnB;;AACA,UACE,EAAE,qBAAqBD,IAAvB,KACA,EAAE,iBAAiBA,IAAnB,CADA,IAEA,EAAE,qBAAqBA,IAAvB,CAHF,EAIE;AACA,cAAM,IAAIE,KAAJ,CAAU,2BAAV,CAAN;AACD;;AAED,aAAO;AAAEpB,QAAAA,IAAI,EAAEf,UAAU,CAACgD,KAAnB;AAA0B/B,QAAAA,GAAG,EAAEG,OAA/B;AAAwC6B,QAAAA,QAAQ,EAAEpD,kBAAkB,CAACoC,IAAD;AAApE,OAAP;AACD;AACF,GA7BD,CA6BE,OAAOK,GAAP,EAAY;AACZvC,IAAAA,WAAW,CAACuC,GAAD,EAAM,kBAAN,CAAX;AACA,WAAO,OAAP;AACD;AACF","sourcesContent":["import { configFromInit, configFromAccounts } from \"./config\";\nimport { sleep, reportError } from \"utils\";\nimport { Action, Dispatch, ActionType } from \"./index\";\nimport { Account } from \"@solana/web3.js\";\n\nconst SPLIT = ((): number | undefined => {\n  const split = parseInt(\n    new URLSearchParams(window.location.search).get(\"split\") || \"\"\n  );\n  if (!isNaN(split)) {\n    return split;\n  }\n})();\n\ntype InitRequest = {\n  route: \"init\";\n};\n\ntype AccountsRequest = {\n  route: \"accounts\";\n  paymentAccount: Account | undefined;\n};\n\ntype Request = AccountsRequest | InitRequest;\n\nexport async function fetchWithRetry(\n  dispatch: Dispatch,\n  httpUrlRef: React.MutableRefObject<string>,\n  request: Request\n) {\n  switch (request.route) {\n    case \"accounts\": {\n      dispatch({\n        type: ActionType.ClearAccounts,\n        url: httpUrlRef.current,\n      });\n      break;\n    }\n    case \"init\": {\n      dispatch({\n        type: ActionType.FetchInit,\n        url: httpUrlRef.current,\n      });\n      break;\n    }\n  }\n\n  const httpUrl = httpUrlRef.current;\n  while (httpUrl === httpUrlRef.current) {\n    let response: Action | \"retry\" | undefined;\n    switch (request.route) {\n      case \"accounts\": {\n        response = await fetchAccounts(httpUrl, request.paymentAccount);\n        break;\n      }\n      case \"init\": {\n        response = await fetchInit(httpUrl);\n      }\n    }\n\n    if (httpUrl !== httpUrlRef.current) break;\n    if (response === \"retry\") {\n      await sleep(2000);\n    } else if (response !== undefined) {\n      dispatch(response);\n      break;\n    }\n  }\n}\n\nasync function fetchInit(httpUrl: string): Promise<Action | \"retry\"> {\n  try {\n    const body = JSON.stringify({ split: SPLIT });\n    const response = await fetch(\n      new Request(httpUrl + \"/init\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body,\n      })\n    );\n    const data = await response.json();\n    if (!(\"clusterUrl\" in data) || !(\"programId\" in data)) {\n      throw new Error(\"Received invalid response\");\n    }\n\n    return {\n      url: httpUrl,\n      type: ActionType.Initialize,\n      config: configFromInit(data),\n    };\n  } catch (err) {\n    reportError(err, \"/init failed\");\n    return \"retry\";\n  }\n}\n\nasync function fetchAccounts(\n  httpUrl: string,\n  paymentAccount: Account | undefined\n): Promise<Action | \"retry\" | undefined> {\n  type RefreshData = {\n    split?: number;\n    paymentKey?: string;\n  };\n\n  const postData: RefreshData = {};\n  if (SPLIT) {\n    postData.split = SPLIT;\n  }\n  if (paymentAccount) {\n    postData.paymentKey = Buffer.from(paymentAccount.secretKey).toString(\n      \"base64\"\n    );\n  }\n\n  try {\n    const body = JSON.stringify(postData);\n    const response = await fetch(\n      new Request(httpUrl + \"/accounts\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body,\n      })\n    );\n\n    if (response.status === 400) {\n      return;\n    } else if (response.status === 500) {\n      const error = await response.text();\n      throw new Error(error);\n    } else {\n      const data = await response.json();\n      if (\n        !(\"programAccounts\" in data) ||\n        !(\"feeAccounts\" in data) ||\n        !(\"accountCapacity\" in data)\n      ) {\n        throw new Error(\"Received invalid response\");\n      }\n\n      return { type: ActionType.Ready, url: httpUrl, accounts: configFromAccounts(data) };\n    }\n  } catch (err) {\n    reportError(err, \"/accounts failed\");\n    return \"retry\";\n  }\n}\n"]},"metadata":{},"sourceType":"module"}