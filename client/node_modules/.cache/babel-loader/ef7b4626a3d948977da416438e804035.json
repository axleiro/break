{"ast":null,"code":"import { Transaction, TransactionInstruction, PublicKey, Account } from \"@solana/web3.js\";\nimport * as Bytes from \"utils/bytes\";\nconst self = globalThis;\nlet clusterUrl;\nlet programId;\nlet feeAccounts;\nlet programAccounts;\nlet blockhash;\nlet socket = new WebSocket(\"wss://break-solana-testnet.herokuapp.com\");\n\nsocket.onmessage = e => {\n  const data = JSON.parse(e.data);\n\n  if (\"activeUsers\" in data) {\n    sendResponse({\n      type: \"users\",\n      count: data.activeUsers\n    });\n  }\n};\n\nfunction sendResponse(response) {\n  self.postMessage(response);\n}\n\nfunction createTransaction(message) {\n  const {\n    trackingId\n  } = message;\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n  const instruction = new TransactionInstruction({\n    keys: [{\n      pubkey: programDataAccount,\n      isWritable: true,\n      isSigner: false\n    }],\n    programId,\n    data: Buffer.from(Bytes.instructionDataFromId(bitId))\n  });\n  const transaction = new Transaction();\n  transaction.add(instruction);\n  transaction.recentBlockhash = blockhash;\n  transaction.sign(feeAccount);\n  const signatureBuffer = transaction.signature;\n  const serializedTransaction = transaction.serialize();\n  socket.send(serializedTransaction);\n  sendResponse({\n    type: \"created\",\n    trackingId: trackingId,\n    signature: signatureBuffer\n  });\n}\n\nself.onmessage = event => {\n  const message = event.data;\n\n  switch (message.type) {\n    case \"init\":\n      {\n        clusterUrl = message.clusterUrl;\n        programId = new PublicKey(message.programId);\n        break;\n      }\n\n    case \"accounts\":\n      {\n        feeAccounts = message.feeAccounts.map(a => new Account(a));\n        programAccounts = message.programAccounts.map(a => new PublicKey(a));\n        break;\n      }\n\n    case \"blockhash\":\n      {\n        blockhash = message.blockhash;\n        break;\n      }\n\n    case \"create\":\n      {\n        try {\n          createTransaction(message);\n        } catch (error) {\n          sendResponse({\n            type: \"failed\",\n            trackingId: message.trackingId,\n            error: error\n          });\n        }\n\n        return;\n      }\n  }\n\n  if (clusterUrl && programId && programAccounts && blockhash) {\n    self.postMessage(\"ready\");\n  }\n};\n\nexport default {};","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/worker/create-transaction-worker-script.ts"],"names":["Transaction","TransactionInstruction","PublicKey","Account","Bytes","self","globalThis","clusterUrl","programId","feeAccounts","programAccounts","blockhash","socket","WebSocket","onmessage","e","data","JSON","parse","sendResponse","type","count","activeUsers","response","postMessage","createTransaction","message","trackingId","bitId","Math","floor","length","accountIndex","programDataAccount","feeAccount","instruction","keys","pubkey","isWritable","isSigner","Buffer","from","instructionDataFromId","transaction","add","recentBlockhash","sign","signatureBuffer","signature","serializedTransaction","serialize","send","event","map","a","error"],"mappings":"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","sourcesContent":["import {\n  Transaction,\n  TransactionInstruction,\n  PublicKey,\n  Account,\n  Blockhash,\n} from \"@solana/web3.js\";\nimport * as Bytes from \"utils/bytes\";\nimport { CreateTransactionMessage, WorkerMessage, WorkerResponse } from \"./link\";\n\nconst self: any = globalThis;\n\nlet clusterUrl: string;\nlet programId: PublicKey;\nlet feeAccounts: Account[];\nlet programAccounts: PublicKey[];\nlet blockhash: Blockhash;\nlet socket = new WebSocket(\"wss://break-solana-testnet.herokuapp.com\");\n\nsocket.onmessage = (e) => {\n  const data = JSON.parse(e.data);\n  if (\"activeUsers\" in data) {\n    sendResponse({\n      type: \"users\",\n      count: data.activeUsers,\n    });\n  }\n};\n\nfunction sendResponse(response: WorkerResponse) {\n  self.postMessage(response);\n}\n\nfunction createTransaction(message: CreateTransactionMessage) {\n  const { trackingId } = message;\n\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n\n  const instruction = new TransactionInstruction({\n    keys: [\n      {\n        pubkey: programDataAccount,\n        isWritable: true,\n        isSigner: false,\n      },\n    ],\n    programId,\n    data: Buffer.from(Bytes.instructionDataFromId(bitId)),\n  });\n\n  const transaction = new Transaction();\n  transaction.add(instruction);\n  transaction.recentBlockhash = blockhash;\n  transaction.sign(feeAccount);\n\n  const signatureBuffer = transaction.signature as Buffer;\n  const serializedTransaction = transaction.serialize();\n  socket.send(serializedTransaction);\n\n  sendResponse({\n    type: \"created\",\n    trackingId: trackingId,\n    signature: signatureBuffer,\n  });\n}\n\nself.onmessage = (event: any) => {\n  const message: WorkerMessage = event.data;\n  switch(message.type) {\n    case \"init\": {\n      clusterUrl = message.clusterUrl;\n      programId = new PublicKey(message.programId);\n      break;\n    }\n\n    case \"accounts\": {\n      feeAccounts = message.feeAccounts.map(a => new Account(a));\n      programAccounts = message.programAccounts.map(a => new PublicKey(a));\n      break;\n    }\n\n    case \"blockhash\": {\n      blockhash = message.blockhash;\n      break;\n    }\n\n    case \"create\": {\n      try {\n        createTransaction(message);\n      } catch (error) {\n        sendResponse({\n          type: \"failed\",\n          trackingId: message.trackingId,\n          error: error,\n        });\n      }\n      return;\n    }\n  }\n\n  if (clusterUrl && programId && programAccounts && blockhash) {\n    self.postMessage(\"ready\");\n  }\n\n};\n\nexport default {};\n"]},"metadata":{},"sourceType":"module"}