{"ast":null,"code":"var _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/create.tsx\";\nimport * as React from \"react\";\nimport bs58 from \"bs58\";\nimport { useTargetSlotRef, useDispatch } from \"./index\";\nimport { useConfig, useAccounts } from \"providers/api\";\nimport { reportError } from \"utils\";\nimport { CreateTransactionRPC } from \"../../workers/create-transaction-rpc\";\nimport { useWorkerState } from \"providers/worker\";\nconst SEND_TIMEOUT_MS = 45000;\nconst RETRY_INTERVAL_MS = 500;\nexport const CreateTxContext = React.createContext(undefined);\nexport function CreateTxProvider({\n  children\n}) {\n  const createTx = React.useRef(() => {});\n  const config = useConfig();\n  const accounts = useAccounts();\n  const idCounter = React.useRef(0);\n  const targetSlotRef = useTargetSlotRef();\n  const programDataAccount = accounts === null || accounts === void 0 ? void 0 : accounts.programAccounts[0].toBase58();\n  const workerState = useWorkerState(); // Reset counter when program data accounts are refreshed\n\n  React.useEffect(() => {\n    idCounter.current = 0;\n  }, [programDataAccount]);\n  const dispatch = useDispatch();\n  React.useEffect(() => {\n    createTx.current = () => {\n      if (workerState === \"loading\" || !config || !accounts || !targetSlotRef.current) return;\n      const id = idCounter.current;\n\n      if (id < accounts.accountCapacity * accounts.programAccounts.length) {\n        idCounter.current++;\n        createTransaction(blockhash, targetSlotRef.current, config.programId, accounts, id, dispatch, socket);\n      } else {\n        reportError(new Error(\"Account capacity exceeded\"), \"failed to create transaction\");\n      }\n    };\n  }, [blockhash, socket, config, accounts, dispatch, targetSlotRef]);\n  return /*#__PURE__*/React.createElement(CreateTxContext.Provider, {\n    value: createTx,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 75,\n      columnNumber: 5\n    }\n  }, children);\n}\nconst workerRPC = new CreateTransactionRPC();\nexport function createTransaction(blockhash, targetSlot, programId, accounts, trackingId, dispatch, socket) {\n  const {\n    feeAccounts,\n    programAccounts\n  } = accounts;\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n  workerRPC.createTransaction({\n    trackingId: trackingId,\n    blockhash: blockhash,\n    programId: programId.toBase58(),\n    programDataAccount: programDataAccount.toBase58(),\n    bitId: bitId,\n    feeAccountSecretKey: feeAccount.secretKey\n  }).then(response => {\n    const {\n      signature,\n      serializedTransaction\n    } = response;\n    const sentAt = performance.now();\n    const pendingTransaction = {\n      sentAt,\n      targetSlot\n    };\n    pendingTransaction.timeoutId = window.setTimeout(() => {\n      dispatch({\n        type: \"timeout\",\n        trackingId\n      });\n    }, SEND_TIMEOUT_MS);\n    const details = {\n      id: bitId,\n      feeAccount: feeAccount.publicKey,\n      programAccount: programDataAccount,\n      signature: bs58.encode(signature)\n    };\n    dispatch({\n      type: \"new\",\n      details,\n      trackingId,\n      pendingTransaction\n    });\n    setTimeout(() => {\n      const retryUntil = new URLSearchParams(window.location.search).get(\"retry_until\");\n\n      if (retryUntil === null || retryUntil !== \"disabled\") {\n        pendingTransaction.retryId = window.setInterval(() => {\n          if (socket.readyState === WebSocket.OPEN) {\n            socket.send(serializedTransaction);\n          }\n        }, RETRY_INTERVAL_MS);\n      }\n    }, 1);\n  }, error => {\n    console.error(error);\n  });\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/create.tsx"],"names":["React","bs58","useTargetSlotRef","useDispatch","useConfig","useAccounts","reportError","CreateTransactionRPC","useWorkerState","SEND_TIMEOUT_MS","RETRY_INTERVAL_MS","CreateTxContext","createContext","undefined","CreateTxProvider","children","createTx","useRef","config","accounts","idCounter","targetSlotRef","programDataAccount","programAccounts","toBase58","workerState","useEffect","current","dispatch","id","accountCapacity","length","createTransaction","blockhash","programId","socket","Error","workerRPC","targetSlot","trackingId","feeAccounts","bitId","Math","floor","accountIndex","feeAccount","feeAccountSecretKey","secretKey","then","response","signature","serializedTransaction","sentAt","performance","now","pendingTransaction","timeoutId","window","setTimeout","type","details","publicKey","programAccount","encode","retryUntil","URLSearchParams","location","search","get","retryId","setInterval","readyState","WebSocket","OPEN","send","error","console"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { Blockhash, PublicKey } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport {\n  Dispatch,\n  PendingTransaction,\n  TransactionDetails,\n  useTargetSlotRef,\n  useDispatch,\n} from \"./index\";\nimport { AccountsConfig } from \"../api/config\";\nimport { useConfig, useAccounts } from \"providers/api\";\nimport { useBlockhash } from \"providers/blockhash\";\nimport { reportError } from \"utils\";\nimport {\n  CreateTransactionRPC,\n  CreateTransactionResponseMessage,\n} from \"../../workers/create-transaction-rpc\";\nimport { useWorkerState } from \"providers/worker\";\n\nconst SEND_TIMEOUT_MS = 45000;\nconst RETRY_INTERVAL_MS = 500;\n\nexport const CreateTxContext = React.createContext<\n  React.MutableRefObject<() => void | undefined> | undefined\n>(undefined);\n\ntype ProviderProps = { children: React.ReactNode };\nexport function CreateTxProvider({ children }: ProviderProps) {\n  const createTx = React.useRef(() => {});\n  const config = useConfig();\n  const accounts = useAccounts();\n  const idCounter = React.useRef<number>(0);\n  const targetSlotRef = useTargetSlotRef();\n  const programDataAccount = accounts?.programAccounts[0].toBase58();\n  const workerState = useWorkerState();\n\n  // Reset counter when program data accounts are refreshed\n  React.useEffect(() => {\n    idCounter.current = 0;\n  }, [programDataAccount]);\n\n  const dispatch = useDispatch();\n  React.useEffect(() => {\n    createTx.current = () => {\n      if (\n        workerState === \"loading\" ||\n        !config ||\n        !accounts ||\n        !targetSlotRef.current\n      )\n        return;\n      const id = idCounter.current;\n      if (id < accounts.accountCapacity * accounts.programAccounts.length) {\n        idCounter.current++;\n        createTransaction(\n          blockhash,\n          targetSlotRef.current,\n          config.programId,\n          accounts,\n          id,\n          dispatch,\n          socket\n        );\n      } else {\n        reportError(\n          new Error(\"Account capacity exceeded\"),\n          \"failed to create transaction\"\n        );\n      }\n    };\n  }, [blockhash, socket, config, accounts, dispatch, targetSlotRef]);\n\n  return (\n    <CreateTxContext.Provider value={createTx}>\n      {children}\n    </CreateTxContext.Provider>\n  );\n}\n\nconst workerRPC = new CreateTransactionRPC();\n\nexport function createTransaction(\n  blockhash: Blockhash,\n  targetSlot: number,\n  programId: PublicKey,\n  accounts: AccountsConfig,\n  trackingId: number,\n  dispatch: Dispatch,\n  socket: WebSocket\n) {\n  const { feeAccounts, programAccounts } = accounts;\n\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n\n  workerRPC\n    .createTransaction({\n      trackingId: trackingId,\n      blockhash: blockhash,\n      programId: programId.toBase58(),\n      programDataAccount: programDataAccount.toBase58(),\n      bitId: bitId,\n      feeAccountSecretKey: feeAccount.secretKey,\n    })\n    .then(\n      (response: CreateTransactionResponseMessage) => {\n        const { signature, serializedTransaction } = response;\n\n        const sentAt = performance.now();\n\n        const pendingTransaction: PendingTransaction = { sentAt, targetSlot };\n        pendingTransaction.timeoutId = window.setTimeout(() => {\n          dispatch({ type: \"timeout\", trackingId });\n        }, SEND_TIMEOUT_MS);\n\n        const details: TransactionDetails = {\n          id: bitId,\n          feeAccount: feeAccount.publicKey,\n          programAccount: programDataAccount,\n          signature: bs58.encode(signature),\n        };\n\n        dispatch({\n          type: \"new\",\n          details,\n          trackingId,\n          pendingTransaction,\n        });\n\n        setTimeout(() => {\n          const retryUntil = new URLSearchParams(window.location.search).get(\n            \"retry_until\"\n          );\n          if (retryUntil === null || retryUntil !== \"disabled\") {\n            pendingTransaction.retryId = window.setInterval(() => {\n              if (socket.readyState === WebSocket.OPEN) {\n                socket.send(serializedTransaction);\n              }\n            }, RETRY_INTERVAL_MS);\n          }\n        }, 1);\n      },\n      (error: any) => {\n        console.error(error);\n      }\n    );\n}\n"]},"metadata":{},"sourceType":"module"}