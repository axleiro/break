{"ast":null,"code":"import { Transaction, TransactionInstruction } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport * as Bytes from \"utils/bytes\";\nimport { ActionType } from \"./index\";\nconst SEND_TIMEOUT_MS = 45000;\nconst RETRY_INTERVAL_MS = 500;\nexport function createTransaction(blockhash, targetSlot, programId, accounts, trackingId, dispatch, socket) {\n  const {\n    feeAccounts,\n    programAccounts\n  } = accounts;\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n  const instruction = new TransactionInstruction({\n    keys: [{\n      pubkey: programDataAccount,\n      isWritable: true,\n      isSigner: false\n    }],\n    programId,\n    data: Buffer.from(Bytes.instructionDataFromId(bitId))\n  });\n  const transaction = new Transaction();\n  transaction.add(instruction);\n  const sentAt = performance.now();\n  transaction.recentBlockhash = blockhash;\n  transaction.sign(feeAccount);\n  const signatureBuffer = transaction.signature;\n  if (!signatureBuffer) throw new Error(\"Failed to sign transaction\");\n  const signature = bs58.encode(signatureBuffer);\n  const pendingTransaction = {\n    sentAt,\n    targetSlot\n  };\n  pendingTransaction.timeoutId = window.setTimeout(() => {\n    dispatch({\n      type: ActionType.TimeoutTransaction,\n      trackingId\n    });\n  }, SEND_TIMEOUT_MS);\n  const details = {\n    id: bitId,\n    feeAccount: feeAccount.publicKey,\n    programAccount: programDataAccount,\n    signature\n  };\n  dispatch({\n    type: ActionType.NewTransaction,\n    details,\n    trackingId,\n    pendingTransaction\n  });\n  setTimeout(() => {\n    const serialized = transaction.serialize();\n    socket.send(serialized);\n    const retryUntil = new URLSearchParams(window.location.search).get(\"retry_until\");\n\n    if (retryUntil === null || retryUntil !== \"disabled\") {\n      pendingTransaction.retryId = window.setInterval(() => {\n        if (socket.readyState === WebSocket.OPEN) {\n          socket.send(serialized);\n        }\n      }, RETRY_INTERVAL_MS);\n    }\n  }, 1);\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/create.tsx"],"names":["Transaction","TransactionInstruction","bs58","Bytes","ActionType","SEND_TIMEOUT_MS","RETRY_INTERVAL_MS","createTransaction","blockhash","targetSlot","programId","accounts","trackingId","dispatch","socket","feeAccounts","programAccounts","bitId","Math","floor","length","accountIndex","programDataAccount","feeAccount","instruction","keys","pubkey","isWritable","isSigner","data","Buffer","from","instructionDataFromId","transaction","add","sentAt","performance","now","recentBlockhash","sign","signatureBuffer","signature","Error","encode","pendingTransaction","timeoutId","window","setTimeout","type","TimeoutTransaction","details","id","publicKey","programAccount","NewTransaction","serialized","serialize","send","retryUntil","URLSearchParams","location","search","get","retryId","setInterval","readyState","WebSocket","OPEN"],"mappings":"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","sourcesContent":["import {\n  Blockhash,\n  Transaction,\n  TransactionInstruction,\n  PublicKey,\n} from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport * as Bytes from \"utils/bytes\";\nimport {\n  Dispatch,\n  PendingTransaction,\n  ActionType,\n  TransactionDetails,\n} from \"./index\";\nimport { AccountsConfig } from \"../api/config\";\n\nconst SEND_TIMEOUT_MS = 45000;\nconst RETRY_INTERVAL_MS = 500;\n\nexport function createTransaction(\n  blockhash: Blockhash,\n  targetSlot: number,\n  programId: PublicKey,\n  accounts: AccountsConfig,\n  trackingId: number,\n  dispatch: Dispatch,\n  socket: WebSocket\n) {\n  const { feeAccounts, programAccounts } = accounts;\n\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n  const instruction = new TransactionInstruction({\n    keys: [{ pubkey: programDataAccount, isWritable: true, isSigner: false }],\n    programId,\n    data: Buffer.from(Bytes.instructionDataFromId(bitId)),\n  });\n\n  const transaction = new Transaction();\n  transaction.add(instruction);\n\n  const sentAt = performance.now();\n  transaction.recentBlockhash = blockhash;\n  transaction.sign(feeAccount);\n  const signatureBuffer = transaction.signature;\n  if (!signatureBuffer) throw new Error(\"Failed to sign transaction\");\n  const signature = bs58.encode(signatureBuffer);\n  const pendingTransaction: PendingTransaction = { sentAt, targetSlot };\n  pendingTransaction.timeoutId = window.setTimeout(() => {\n    dispatch({ type: ActionType.TimeoutTransaction, trackingId });\n  }, SEND_TIMEOUT_MS);\n\n  const details: TransactionDetails = {\n    id: bitId,\n    feeAccount: feeAccount.publicKey,\n    programAccount: programDataAccount,\n    signature,\n  };\n\n  dispatch({\n    type: ActionType.NewTransaction,\n    details,\n    trackingId,\n    pendingTransaction,\n  });\n\n  setTimeout(() => {\n    const serialized = transaction.serialize();\n    socket.send(serialized);\n\n    const retryUntil = new URLSearchParams(window.location.search).get(\n      \"retry_until\"\n    );\n    if (retryUntil === null || retryUntil !== \"disabled\") {\n      pendingTransaction.retryId = window.setInterval(() => {\n        if (socket.readyState === WebSocket.OPEN) {\n          socket.send(serialized);\n        }\n      }, RETRY_INTERVAL_MS);\n    }\n  }, 1);\n}\n"]},"metadata":{},"sourceType":"module"}