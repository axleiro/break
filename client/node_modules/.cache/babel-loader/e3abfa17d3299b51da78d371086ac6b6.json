{"ast":null,"code":"var _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/index.tsx\";\nimport * as React from \"react\";\nimport { useThrottle } from \"@react-hook/throttle\";\nimport { useConnection } from \"../api\";\nimport { ConfirmedHelper } from \"./confirmed\";\nimport { TpsProvider, TpsContext } from \"./tps\";\nimport { CreateTxContext, CreateTxProvider } from \"./create\";\nimport { SelectedTxProvider } from \"./selected\";\nexport const COMMITMENT_PARAM = (() => {\n  const commitment = new URLSearchParams(window.location.search).get(\"commitment\");\n\n  switch (commitment) {\n    case \"recent\":\n    case \"single\":\n      {\n        return commitment;\n      }\n\n    default:\n      {\n        return \"singleGossip\";\n      }\n  }\n})();\nlet lastReduce = performance.now();\n\nfunction reducer(state, action) {\n  console.log(\"ACTION\", action.type);\n\n  switch (action.type) {\n    case \"new\":\n      {\n        const {\n          details,\n          pendingTransaction\n        } = action;\n        return [...state, {\n          details,\n          status: \"pending\",\n          pending: pendingTransaction\n        }];\n      }\n\n    case \"timeout\":\n      {\n        const trackingId = action.trackingId;\n        if (trackingId >= state.length) return state;\n        const timeout = state[trackingId];\n        if (timeout.status !== \"pending\") return state;\n        clearInterval(timeout.pending.retryId);\n        return state.map(tx => {\n          if (tx.details.signature === timeout.details.signature) {\n            return {\n              status: \"timeout\",\n              details: tx.details\n            };\n          } else {\n            return tx;\n          }\n        });\n      }\n\n    case \"update\":\n      {\n        const {\n          ids,\n          partition,\n          partitionCount\n        } = action.activeIdPartition;\n        const start = performance.now();\n        const newState = state.map((tx, trackingId) => {\n          if (trackingId % partitionCount !== partition) return tx;\n          const id = Math.floor(trackingId / partitionCount);\n\n          if (tx.status === \"pending\" && ids.has(id)) {\n            // Optimistically confirmed, no need to continue retry\n            if (action.commitment === \"singleGossip\" || action.commitment === \"single\") {\n              clearInterval(tx.pending.retryId);\n              clearTimeout(tx.pending.timeoutId);\n            }\n\n            return {\n              status: \"success\",\n              details: tx.details,\n              slot: {\n                target: tx.pending.targetSlot,\n                estimated: action.estimatedSlot\n              },\n              timing: {\n                sentAt: tx.pending.sentAt,\n                [action.commitment]: timeElapsed(tx.pending.sentAt, action.receivedAt)\n              },\n              pending: tx.pending\n            };\n          } else if (tx.status === \"success\") {\n            if (ids.has(id)) {\n              // Already recorded conf time\n              if (tx.timing[action.commitment] !== undefined) {\n                return tx;\n              } // Optimistically confirmed, no need to continue retry\n\n\n              if (tx.pending && (action.commitment === \"singleGossip\" || action.commitment === \"single\")) {\n                clearInterval(tx.pending.retryId);\n                clearTimeout(tx.pending.timeoutId);\n              }\n\n              return { ...tx,\n                timing: { ...tx.timing,\n                  [action.commitment]: timeElapsed(tx.timing.sentAt, action.receivedAt)\n                }\n              };\n            } else if (action.commitment === \"recent\" && tx.pending && !ids.has(id)) {\n              // Don't revert to pending state if we already received timing info for other commitments\n              if (tx.timing[\"single\"] !== undefined || tx.timing[\"singleGossip\"] !== undefined) {\n                return { ...tx,\n                  timing: { ...tx.timing,\n                    recent: undefined\n                  }\n                };\n              } // Revert to pending state because the previous notification likely came from a fork\n\n\n              return {\n                status: \"pending\",\n                details: tx.details,\n                pending: { ...tx.pending\n                }\n              };\n            }\n          }\n\n          return tx;\n        }); // console.log(\"REDUCE\", performance.now() - start, performance.now());\n\n        const now = performance.now();\n        console.log(\"SINCE LAST REDUCE\", now - lastReduce);\n        lastReduce = now;\n        return newState;\n      }\n\n    case \"reset\":\n      {\n        state.forEach(tx => {\n          if (tx.status === \"pending\") {\n            clearTimeout(tx.pending.timeoutId);\n            clearInterval(tx.pending.retryId);\n          } else if (tx.status === \"success\" && tx.pending) {\n            clearTimeout(tx.pending.timeoutId);\n            clearInterval(tx.pending.retryId);\n          }\n        });\n        return [];\n      }\n\n    case \"root\":\n      {\n        const foundRooted = state.find(tx => {\n          return tx.status === \"success\" && tx.pending && tx.slot.landed === action.root;\n        });\n        if (!foundRooted) return state;\n        return state.map(tx => {\n          if (tx.status === \"success\" && tx.pending && tx.slot.landed === action.root) {\n            clearInterval(tx.pending.retryId);\n            clearTimeout(tx.pending.timeoutId);\n            return { ...tx,\n              pending: undefined\n            };\n          } else {\n            return tx;\n          }\n        });\n      }\n\n    case \"landed\":\n      {\n        return state.map(tx => {\n          if (tx.status === \"success\") {\n            const index = action.signatures.findIndex(val => val === tx.details.signature);\n\n            if (index >= 0) {\n              return { ...tx,\n                slot: { ...tx.slot,\n                  landed: action.slots[index]\n                }\n              };\n            }\n          }\n\n          return tx;\n        });\n      }\n  }\n}\n\nconst SlotContext = React.createContext(undefined);\nconst StateContext = React.createContext(undefined);\nconst DispatchContext = React.createContext(undefined);\nconst BLAH = [];\nexport function TransactionsProvider({\n  children\n}) {\n  const [state, dispatch] = React.useReducer(reducer, []);\n  const connection = useConnection();\n  const targetSlot = React.useRef();\n  const stateRef = React.useRef(state);\n  React.useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n  React.useEffect(() => {\n    dispatch({\n      type: ActionType.ResetState\n    });\n    if (connection === undefined) return;\n    const slotSubscription = connection.onSlotChange(({\n      slot\n    }) => {\n      targetSlot.current = slot;\n    });\n    const rootSubscription = connection.onRootChange(root => {\n      dispatch({\n        type: ActionType.RecordRoot,\n        root\n      });\n    }); // Poll for signature statuses to determine which slot a tx landed in\n\n    const intervalId = setInterval(async () => {\n      const fetchStatuses = [];\n      stateRef.current.forEach(tx => {\n        if (tx.status === \"success\" && tx.slot.landed === undefined) {\n          fetchStatuses.push(tx.details.signature);\n        }\n      });\n      if (fetchStatuses.length === 0) return;\n      const slots = [];\n      const signatures = [];\n      const statuses = (await connection.getSignatureStatuses(fetchStatuses)).value;\n\n      for (var i = 0; i < statuses.length; i++) {\n        const status = statuses[i];\n\n        if (status !== null) {\n          slots.push(status.slot);\n          signatures.push(fetchStatuses[i]);\n        }\n      }\n\n      if (slots.length === 0) return;\n      dispatch({\n        type: ActionType.LandedTxs,\n        slots,\n        signatures\n      });\n    }, 2000);\n    return () => {\n      connection.removeSlotChangeListener(slotSubscription);\n      connection.removeRootChangeListener(rootSubscription);\n      clearInterval(intervalId);\n    };\n  }, [connection]);\n  const [throttledState, setThrottledState] = useThrottle(state, 2);\n  React.useEffect(() => {\n    setThrottledState(state);\n  }, [state, setThrottledState]);\n  return /*#__PURE__*/React.createElement(StateContext.Provider, {\n    value: throttledState,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 392,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(DispatchContext.Provider, {\n    value: dispatch,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 393,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(SlotContext.Provider, {\n    value: targetSlot,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 394,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(SelectedTxProvider, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 395,\n      columnNumber: 11\n    }\n  }, /*#__PURE__*/React.createElement(CreateTxProvider, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 396,\n      columnNumber: 13\n    }\n  }, /*#__PURE__*/React.createElement(ConfirmedHelper, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 397,\n      columnNumber: 15\n    }\n  }, /*#__PURE__*/React.createElement(TpsProvider, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 398,\n      columnNumber: 17\n    }\n  }, children)))))));\n}\n\nfunction timeElapsed(sentAt, receivedAt = performance.now()) {\n  return parseFloat(((receivedAt - sentAt) / 1000).toFixed(3));\n}\n\nexport function useDispatch() {\n  const dispatch = React.useContext(DispatchContext);\n\n  if (!dispatch) {\n    throw new Error(`useDispatch must be used within a TransactionsProvider`);\n  }\n\n  return dispatch;\n}\nexport function useTargetSlotRef() {\n  const dispatch = React.useContext(SlotContext);\n\n  if (!dispatch) {\n    throw new Error(`useTargetSlotRef must be used within a TransactionsProvider`);\n  }\n\n  return dispatch;\n}\nexport function useTransactions() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useTransactions must be used within a TransactionsProvider`);\n  }\n\n  return state;\n}\nexport function useConfirmedCount() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useConfirmedCount must be used within a TransactionsProvider`);\n  }\n\n  return state.filter(({\n    status\n  }) => status === \"success\").length;\n}\nexport function useDroppedCount() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useDroppedCount must be used within a TransactionsProvider`);\n  }\n\n  return state.filter(({\n    status\n  }) => status === \"timeout\").length;\n}\nexport function useAvgConfirmationTime() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useAvgConfirmationTime must be used within a TransactionsProvider`);\n  }\n\n  const confirmed = state.reduce((confirmed, tx) => {\n    if (tx.status === \"success\") {\n      const confTime = tx.timing[COMMITMENT_PARAM];\n      if (confTime !== undefined) confirmed.push(confTime);\n    }\n\n    return confirmed;\n  }, []);\n  const count = confirmed.length;\n  if (count === 0) return 0;\n  const sum = confirmed.reduce((sum, time) => sum + time, 0);\n  return sum / count;\n}\nexport function useCreatedCount() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useCreatedCount must be used within a TransactionsProvider`);\n  }\n\n  return state.length;\n}\nexport function useTps() {\n  const tps = React.useContext(TpsContext);\n  if (tps === undefined) throw new Error(`useTps must be used within a TransactionsProvider`);\n  return tps;\n}\nexport function useCreateTxRef() {\n  const tps = React.useContext(CreateTxContext);\n  if (tps === undefined) throw new Error(`useCreateTxRef must be used within a TransactionsProvider`);\n  return tps;\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/index.tsx"],"names":["React","useThrottle","useConnection","ConfirmedHelper","TpsProvider","TpsContext","CreateTxContext","CreateTxProvider","SelectedTxProvider","COMMITMENT_PARAM","commitment","URLSearchParams","window","location","search","get","lastReduce","performance","now","reducer","state","action","console","log","type","details","pendingTransaction","status","pending","trackingId","length","timeout","clearInterval","retryId","map","tx","signature","ids","partition","partitionCount","activeIdPartition","start","newState","id","Math","floor","has","clearTimeout","timeoutId","slot","target","targetSlot","estimated","estimatedSlot","timing","sentAt","timeElapsed","receivedAt","undefined","recent","forEach","foundRooted","find","landed","root","index","signatures","findIndex","val","slots","SlotContext","createContext","StateContext","DispatchContext","BLAH","TransactionsProvider","children","dispatch","useReducer","connection","useRef","stateRef","useEffect","current","ActionType","ResetState","slotSubscription","onSlotChange","rootSubscription","onRootChange","RecordRoot","intervalId","setInterval","fetchStatuses","push","statuses","getSignatureStatuses","value","i","LandedTxs","removeSlotChangeListener","removeRootChangeListener","throttledState","setThrottledState","parseFloat","toFixed","useDispatch","useContext","Error","useTargetSlotRef","useTransactions","useConfirmedCount","filter","useDroppedCount","useAvgConfirmationTime","confirmed","reduce","confTime","count","sum","time","useCreatedCount","useTps","tps","useCreateTxRef"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { useThrottle } from \"@react-hook/throttle\";\nimport { TransactionSignature, PublicKey } from \"@solana/web3.js\";\nimport { useConnection } from \"../api\";\nimport { ConfirmedHelper } from \"./confirmed\";\nimport { TpsProvider, TpsContext } from \"./tps\";\nimport { CreateTxContext, CreateTxProvider } from \"./create\";\nimport { SelectedTxProvider } from \"./selected\";\n\nexport type PendingTransaction = {\n  sentAt: number;\n  targetSlot: number;\n  retryId?: number;\n  timeoutId?: number;\n};\n\nexport type TransactionDetails = {\n  id: number;\n  feeAccount: PublicKey;\n  programAccount: PublicKey;\n  signature: TransactionSignature;\n};\n\ntype Timing = {\n  sentAt: number;\n  recent?: number;\n  single?: number;\n  singleGossip?: number;\n};\n\ntype SuccessState = {\n  status: \"success\";\n  details: TransactionDetails;\n  slot: {\n    target: number;\n    landed?: number;\n    estimated: number;\n  };\n  timing: Timing;\n  pending?: PendingTransaction;\n};\n\nexport const COMMITMENT_PARAM = ((): TrackedCommitment => {\n  const commitment = new URLSearchParams(window.location.search).get(\n    \"commitment\"\n  );\n  switch (commitment) {\n    case \"recent\":\n    case \"single\": {\n      return commitment;\n    }\n    default: {\n      return \"singleGossip\";\n    }\n  }\n})();\n\nexport type TrackedCommitment = \"single\" | \"singleGossip\" | \"recent\";\n\ntype TimeoutState = {\n  status: \"timeout\";\n  details: TransactionDetails;\n};\n\ntype PendingState = {\n  status: \"pending\";\n  pending: PendingTransaction;\n  details: TransactionDetails;\n};\n\nexport type TransactionStatus = \"success\" | \"timeout\" | \"pending\";\n\nexport type TransactionState = SuccessState | TimeoutState | PendingState;\n\nexport type ActionType = \"new\" | \"update\" | \"timeout\" | \"reset\" | \"root\" | \"landed\";\n// export enum ActionType = {\n//   NewTransaction,\n//   UpdateIds,\n//   TimeoutTransaction,\n//   ResetState,\n//   RecordRoot,\n//   LandedTxs,\n// }\n\ntype UpdateIds = {\n  // type: ActionType.UpdateIds;\n  type: \"update\";\n  activeIdPartition: {\n    ids: Set<number>;\n    partition: number;\n    partitionCount: number;\n  };\n  commitment: TrackedCommitment;\n  receivedAt: number;\n  estimatedSlot: number;\n};\n\ntype LandedTxs = {\n  type: \"landed\",\n  signatures: TransactionSignature[];\n  slots: number[];\n};\n\ntype NewTransaction = {\n  type: \"new\";\n  trackingId: number;\n  details: TransactionDetails;\n  pendingTransaction: PendingTransaction;\n};\n\ntype TimeoutTransaction = {\n  type: \"timeout\";\n  trackingId: number;\n};\n\ntype ResetState = {\n  type: \"reset\";\n};\n\ntype RecordRoot = {\n  type: \"root\";\n  root: number;\n};\n\ntype Action =\n  | NewTransaction\n  | UpdateIds\n  | TimeoutTransaction\n  | ResetState\n  | RecordRoot\n  | LandedTxs;\n\ntype State = TransactionState[];\nlet lastReduce = performance.now();\nfunction reducer(state: State, action: Action): State {\n  console.log(\"ACTION\", action.type);\n  switch (action.type) {\n    case \"new\": {\n      const { details, pendingTransaction } = action;\n      return [\n        ...state,\n        {\n          details,\n          status: \"pending\",\n          pending: pendingTransaction,\n        },\n      ];\n    }\n\n    case \"timeout\": {\n      const trackingId = action.trackingId;\n      if (trackingId >= state.length) return state;\n      const timeout = state[trackingId];\n      if (timeout.status !== \"pending\") return state;\n      clearInterval(timeout.pending.retryId);\n\n      return state.map((tx) => {\n        if (tx.details.signature === timeout.details.signature) {\n          return {\n            status: \"timeout\",\n            details: tx.details,\n          };\n        } else {\n          return tx;\n        }\n      });\n    }\n\n    case \"update\": {\n      const { ids, partition, partitionCount } = action.activeIdPartition;\n      const start = performance.now();\n      const newState: State = state.map((tx, trackingId) => {\n        if (trackingId % partitionCount !== partition) return tx;\n        const id = Math.floor(trackingId / partitionCount);\n        if (tx.status === \"pending\" && ids.has(id)) {\n          // Optimistically confirmed, no need to continue retry\n          if (\n            action.commitment === \"singleGossip\" ||\n            action.commitment === \"single\"\n          ) {\n            clearInterval(tx.pending.retryId);\n            clearTimeout(tx.pending.timeoutId);\n          }\n\n          return {\n            status: \"success\",\n            details: tx.details,\n            slot: {\n              target: tx.pending.targetSlot,\n              estimated: action.estimatedSlot,\n            },\n            timing: {\n              sentAt: tx.pending.sentAt,\n              [action.commitment]: timeElapsed(tx.pending.sentAt, action.receivedAt),\n            },\n            pending: tx.pending,\n          };\n        } else if (tx.status === \"success\") {\n          if (ids.has(id)) {\n            // Already recorded conf time\n            if (tx.timing[action.commitment] !== undefined) {\n              return tx;\n            }\n\n            // Optimistically confirmed, no need to continue retry\n            if (\n              tx.pending &&\n              (action.commitment === \"singleGossip\" ||\n                action.commitment === \"single\")\n            ) {\n              clearInterval(tx.pending.retryId);\n              clearTimeout(tx.pending.timeoutId);\n            }\n\n            return {\n              ...tx,\n              timing: {\n                ...tx.timing,\n                [action.commitment]: timeElapsed(tx.timing.sentAt, action.receivedAt),\n              },\n            };\n          } else if (\n            action.commitment === \"recent\" &&\n            tx.pending &&\n            !ids.has(id)\n          ) {\n            // Don't revert to pending state if we already received timing info for other commitments\n            if (\n              tx.timing[\"single\"] !== undefined ||\n              tx.timing[\"singleGossip\"] !== undefined\n            ) {\n              return {\n                ...tx,\n                timing: {\n                  ...tx.timing,\n                  recent: undefined,\n                },\n              };\n            }\n\n            // Revert to pending state because the previous notification likely came from a fork\n            return {\n              status: \"pending\",\n              details: tx.details,\n              pending: { ...tx.pending },\n            };\n          }\n        }\n        return tx;\n      });\n      // console.log(\"REDUCE\", performance.now() - start, performance.now());\n      const now = performance.now();\n      console.log(\"SINCE LAST REDUCE\", now - lastReduce);\n      lastReduce = now;\n      return newState;\n    }\n\n    case \"reset\": {\n      state.forEach((tx) => {\n        if (tx.status === \"pending\") {\n          clearTimeout(tx.pending.timeoutId);\n          clearInterval(tx.pending.retryId);\n        } else if (tx.status === \"success\" && tx.pending) {\n          clearTimeout(tx.pending.timeoutId);\n          clearInterval(tx.pending.retryId);\n        }\n      });\n      return [];\n    }\n\n    case \"root\": {\n      const foundRooted = state.find((tx) => {\n        return (\n          tx.status === \"success\" &&\n          tx.pending &&\n          tx.slot.landed === action.root\n        );\n      });\n      if (!foundRooted) return state;\n\n      return state.map((tx) => {\n        if (\n          tx.status === \"success\" &&\n          tx.pending &&\n          tx.slot.landed === action.root\n        ) {\n          clearInterval(tx.pending.retryId);\n          clearTimeout(tx.pending.timeoutId);\n          return {\n            ...tx,\n            pending: undefined,\n          };\n        } else {\n          return tx;\n        }\n      });\n    }\n\n    case \"landed\": {\n      return state.map((tx) => {\n        if (tx.status === \"success\") {\n          const index = action.signatures.findIndex(\n            (val) => val === tx.details.signature\n          );\n          if (index >= 0) {\n            return {\n              ...tx,\n              slot: {\n                ...tx.slot,\n                landed: action.slots[index],\n              },\n            };\n          }\n        }\n        return tx;\n      });\n    }\n  }\n}\n\nexport type Dispatch = (action: Action) => void;\nconst SlotContext = React.createContext<\n  React.MutableRefObject<number | undefined> | undefined\n>(undefined);\nconst StateContext = React.createContext<State | undefined>(undefined);\nconst DispatchContext = React.createContext<Dispatch | undefined>(undefined);\n\nconst BLAH: TransactionState[] = [];\ntype ProviderProps = { children: React.ReactNode };\nexport function TransactionsProvider({ children }: ProviderProps) {\n  const [state, dispatch] = React.useReducer(reducer, []);\n  const connection = useConnection();\n  const targetSlot = React.useRef<number>();\n  const stateRef = React.useRef(state);\n\n  React.useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n\n  React.useEffect(() => {\n    dispatch({\n      type: ActionType.ResetState,\n    });\n\n    if (connection === undefined) return;\n    const slotSubscription = connection.onSlotChange(({ slot }) => {\n      targetSlot.current = slot;\n    });\n    const rootSubscription = connection.onRootChange((root) => {\n      dispatch({ type: ActionType.RecordRoot, root });\n    });\n\n    // Poll for signature statuses to determine which slot a tx landed in\n    const intervalId = setInterval(async () => {\n      const fetchStatuses: string[] = [];\n      stateRef.current.forEach((tx) => {\n        if (tx.status === \"success\" && tx.slot.landed === undefined) {\n          fetchStatuses.push(tx.details.signature);\n        }\n      });\n\n      if (fetchStatuses.length === 0) return;\n\n      const slots: number[] = [];\n      const signatures: TransactionSignature[] = [];\n      const statuses = (await connection.getSignatureStatuses(fetchStatuses))\n        .value;\n      for (var i = 0; i < statuses.length; i++) {\n        const status = statuses[i];\n        if (status !== null) {\n          slots.push(status.slot);\n          signatures.push(fetchStatuses[i]);\n        }\n      }\n      if (slots.length === 0) return;\n      dispatch({ type: ActionType.LandedTxs, slots, signatures });\n    }, 2000);\n\n    return () => {\n      connection.removeSlotChangeListener(slotSubscription);\n      connection.removeRootChangeListener(rootSubscription);\n      clearInterval(intervalId);\n    };\n  }, [connection]);\n\n  const [throttledState, setThrottledState] = useThrottle(state, 2);\n  React.useEffect(() => {\n    setThrottledState(state);\n  }, [state, setThrottledState]);\n\n  return (\n    <StateContext.Provider value={throttledState}>\n      <DispatchContext.Provider value={dispatch}>\n        <SlotContext.Provider value={targetSlot}>\n          <SelectedTxProvider>\n            <CreateTxProvider>\n              <ConfirmedHelper>\n                <TpsProvider>{children}</TpsProvider>\n              </ConfirmedHelper>\n            </CreateTxProvider>\n          </SelectedTxProvider>\n        </SlotContext.Provider>\n      </DispatchContext.Provider>\n    </StateContext.Provider>\n  );\n}\n\nfunction timeElapsed(sentAt: number, receivedAt: number = performance.now()): number {\n  return parseFloat(((receivedAt - sentAt) / 1000).toFixed(3));\n}\n\nexport function useDispatch() {\n  const dispatch = React.useContext(DispatchContext);\n  if (!dispatch) {\n    throw new Error(`useDispatch must be used within a TransactionsProvider`);\n  }\n\n  return dispatch;\n}\n\nexport function useTargetSlotRef() {\n  const dispatch = React.useContext(SlotContext);\n  if (!dispatch) {\n    throw new Error(\n      `useTargetSlotRef must be used within a TransactionsProvider`\n    );\n  }\n\n  return dispatch;\n}\n\nexport function useTransactions() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useTransactions must be used within a TransactionsProvider`\n    );\n  }\n\n  return state;\n}\n\nexport function useConfirmedCount() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useConfirmedCount must be used within a TransactionsProvider`\n    );\n  }\n  return state.filter(({ status }) => status === \"success\").length;\n}\n\nexport function useDroppedCount() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useDroppedCount must be used within a TransactionsProvider`\n    );\n  }\n  return state.filter(({ status }) => status === \"timeout\").length;\n}\n\nexport function useAvgConfirmationTime() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useAvgConfirmationTime must be used within a TransactionsProvider`\n    );\n  }\n\n  const confirmed = state.reduce((confirmed: number[], tx) => {\n    if (tx.status === \"success\") {\n      const confTime = tx.timing[COMMITMENT_PARAM];\n      if (confTime !== undefined) confirmed.push(confTime);\n    }\n    return confirmed;\n  }, []);\n\n  const count = confirmed.length;\n  if (count === 0) return 0;\n  const sum = confirmed.reduce((sum, time) => sum + time, 0);\n  return sum / count;\n}\n\nexport function useCreatedCount() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useCreatedCount must be used within a TransactionsProvider`\n    );\n  }\n  return state.length;\n}\n\nexport function useTps() {\n  const tps = React.useContext(TpsContext);\n  if (tps === undefined)\n    throw new Error(`useTps must be used within a TransactionsProvider`);\n  return tps;\n}\n\nexport function useCreateTxRef() {\n  const tps = React.useContext(CreateTxContext);\n  if (tps === undefined)\n    throw new Error(`useCreateTxRef must be used within a TransactionsProvider`);\n  return tps;\n}\n"]},"metadata":{},"sourceType":"module"}