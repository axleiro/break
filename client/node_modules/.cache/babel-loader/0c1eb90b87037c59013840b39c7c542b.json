{"ast":null,"code":"import{Transaction,TransactionInstruction,PublicKey,Account}from\"@solana/web3.js\";import*as Bytes from\"utils/bytes\";var self=globalThis;var clusterUrl;var programId;var feeAccounts;var programAccounts;var blockhash;var socket=new WebSocket(\"wss://break-solana-testnet.herokuapp.com\");function createTransaction(message){var trackingId=message.trackingId;var bitId=Math.floor(trackingId/feeAccounts.length);var accountIndex=trackingId%feeAccounts.length;var programDataAccount=programAccounts[accountIndex];var feeAccount=feeAccounts[accountIndex];var instruction=new TransactionInstruction({keys:[{pubkey:programDataAccount,isWritable:true,isSigner:false}],programId:programId,data:Buffer.from(Bytes.instructionDataFromId(bitId))});var transaction=new Transaction();transaction.add(instruction);transaction.recentBlockhash=blockhash;transaction.sign(feeAccount);var signatureBuffer=transaction.signature;var serializedTransaction=transaction.serialize();socket.send(serializedTransaction);self.postMessage({trackingId:trackingId,signature:signatureBuffer});}self.onmessage=function(event){var message=event.data;switch(message.type){case\"init\":{clusterUrl=message.clusterUrl;programId=new PublicKey(message.programId);break;}case\"accounts\":{feeAccounts=message.feeAccounts.map(function(a){return new Account(a);});programAccounts=message.programAccounts.map(function(a){return new PublicKey(a);});break;}case\"blockhash\":{blockhash=message.blockhash;break;}case\"create\":{try{createTransaction(message);}catch(error){self.postMessage({trackingId:message.trackingId,error:error});}return;}}if(clusterUrl&&programId&&programAccounts&&blockhash){self.postMessage(\"ready\");}};export default{};","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/workers/create-transaction-worker-script.ts"],"names":["Transaction","TransactionInstruction","PublicKey","Account","Bytes","self","globalThis","clusterUrl","programId","feeAccounts","programAccounts","blockhash","socket","WebSocket","createTransaction","message","trackingId","bitId","Math","floor","length","accountIndex","programDataAccount","feeAccount","instruction","keys","pubkey","isWritable","isSigner","data","Buffer","from","instructionDataFromId","transaction","add","recentBlockhash","sign","signatureBuffer","signature","serializedTransaction","serialize","send","postMessage","onmessage","event","type","map","a","error"],"mappings":"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","sourcesContent":["import {\n  Transaction,\n  TransactionInstruction,\n  PublicKey,\n  Account,\n  Blockhash,\n} from \"@solana/web3.js\";\nimport * as Bytes from \"utils/bytes\";\nimport { CreateTransactionMessage, WorkerMessage } from \"./create-transaction-rpc\";\nimport { AccountsConfig } from \"providers/api/config\";\n\nconst self: any = globalThis;\n\nlet clusterUrl: string;\nlet programId: PublicKey;\nlet feeAccounts: Account[];\nlet programAccounts: PublicKey[];\nlet blockhash: Blockhash;\nlet socket = new WebSocket(\"wss://break-solana-testnet.herokuapp.com\");\n\nfunction createTransaction(message: CreateTransactionMessage) {\n  const { trackingId } = message;\n\n  const bitId = Math.floor(trackingId / feeAccounts.length);\n  const accountIndex = trackingId % feeAccounts.length;\n  const programDataAccount = programAccounts[accountIndex];\n  const feeAccount = feeAccounts[accountIndex];\n\n  const instruction = new TransactionInstruction({\n    keys: [\n      {\n        pubkey: programDataAccount,\n        isWritable: true,\n        isSigner: false,\n      },\n    ],\n    programId,\n    data: Buffer.from(Bytes.instructionDataFromId(bitId)),\n  });\n\n  const transaction = new Transaction();\n  transaction.add(instruction);\n  transaction.recentBlockhash = blockhash;\n  transaction.sign(feeAccount);\n\n  const signatureBuffer = transaction.signature;\n  const serializedTransaction = transaction.serialize();\n  socket.send(serializedTransaction);\n\n  self.postMessage({\n    trackingId: trackingId,\n    signature: signatureBuffer,\n  });\n}\n\nself.onmessage = (event: any) => {\n  const message: WorkerMessage = event.data;\n  switch(message.type) {\n    case \"init\": {\n      clusterUrl = message.clusterUrl;\n      programId = new PublicKey(message.programId);\n      break;\n    }\n\n    case \"accounts\": {\n      feeAccounts = message.feeAccounts.map(a => new Account(a));\n      programAccounts = message.programAccounts.map(a => new PublicKey(a));\n      break;\n    }\n\n    case \"blockhash\": {\n      blockhash = message.blockhash;\n      break;\n    }\n\n    case \"create\": {\n      try {\n        createTransaction(message);\n      } catch (error) {\n        self.postMessage({\n          trackingId: message.trackingId,\n          error: error,\n        });\n      }\n      return;\n    }\n  }\n\n  if (clusterUrl && programId && programAccounts && blockhash) {\n    self.postMessage(\"ready\");\n  }\n\n};\n\nexport default {};\n"]},"metadata":{},"sourceType":"module"}