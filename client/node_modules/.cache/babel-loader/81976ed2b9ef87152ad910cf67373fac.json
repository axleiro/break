{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { getCurrentHub, Hub } from '@sentry/hub';\nimport { isInstanceOf, logger } from '@sentry/utils';\nimport { Span as SpanClass, SpanRecorder } from './span';\n/** JSDoc */\n\nvar Transaction =\n/** @class */\nfunction (_super) {\n  __extends(Transaction, _super);\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n\n\n  function Transaction(transactionContext, hub) {\n    var _this = _super.call(this, transactionContext) || this;\n    /**\n     * The reference to the current hub.\n     */\n\n\n    _this._hub = getCurrentHub();\n\n    if (isInstanceOf(hub, Hub)) {\n      _this._hub = hub;\n    }\n\n    if (transactionContext.name) {\n      _this.name = transactionContext.name;\n    }\n\n    _this._trimEnd = transactionContext.trimEnd;\n    return _this;\n  }\n  /**\n   * JSDoc\n   */\n\n\n  Transaction.prototype.setName = function (name) {\n    this.name = name;\n  };\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n\n\n  Transaction.prototype.initSpanRecorder = function (maxlen) {\n    if (maxlen === void 0) {\n      maxlen = 1000;\n    }\n\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n\n    this.spanRecorder.add(this);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Transaction.prototype.finish = function (endTimestamp) {\n    var _this = this; // This transaction is already finished, so we should not flush it again.\n\n\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    _super.prototype.finish.call(this, endTimestamp);\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n      return undefined;\n    }\n\n    var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function (s) {\n      return s !== _this && s.endTimestamp;\n    }) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce(function (prev, current) {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n\n        return prev;\n      }).endTimestamp;\n    }\n\n    return this._hub.captureEvent({\n      contexts: {\n        trace: this.getTraceContext()\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction'\n    });\n  };\n\n  return Transaction;\n}(SpanClass);\n\nexport { Transaction };","map":{"version":3,"sources":["../src/transaction.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub, Hub } from '@sentry/hub';\nimport { TransactionContext } from '@sentry/types';\nimport { isInstanceOf, logger } from '@sentry/utils';\n\nimport { Span as SpanClass, SpanRecorder } from './span';\n\n/** JSDoc */\nexport class Transaction extends SpanClass {\n  public name?: string;\n\n  /**\n   * The reference to the current hub.\n   */\n  private readonly _hub: Hub = (getCurrentHub() as unknown) as Hub;\n\n  private readonly _trimEnd?: boolean;\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  public constructor(transactionContext: TransactionContext, hub?: Hub) {\n    super(transactionContext);\n\n    if (isInstanceOf(hub, Hub)) {\n      this._hub = hub as Hub;\n    }\n\n    if (transactionContext.name) {\n      this.name = transactionContext.name;\n    }\n\n    this._trimEnd = transactionContext.trimEnd;\n  }\n\n  /**\n   * JSDoc\n   */\n  public setName(name: string): void {\n    this.name = name;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n  public initSpanRecorder(maxlen: number = 1000): void {\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public finish(endTimestamp?: number): string | undefined {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    super.finish(endTimestamp);\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n      return undefined;\n    }\n\n    const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev: SpanClass, current: SpanClass) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n\n    return this._hub.captureEvent({\n      contexts: {\n        trace: this.getTraceContext(),\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}