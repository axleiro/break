{"ast":null,"code":"var _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/index.tsx\";\nimport * as React from \"react\";\nimport { useConfig, useAccounts, useConnection } from \"../api\";\nimport { useBlockhash } from \"../blockhash\";\nimport { ConfirmedHelper } from \"./confirmed\";\nimport { TpsProvider, TpsContext } from \"./tps\";\nimport { createTransaction } from \"./create\";\nimport { SelectedTxProvider } from \"./selected\";\nimport { useSocket } from \"../socket\";\nimport { reportError } from \"utils\";\nexport const COMMITMENT_PARAM = (() => {\n  const commitment = new URLSearchParams(window.location.search).get(\"commitment\");\n\n  switch (commitment) {\n    case \"recent\":\n    case \"single\":\n      {\n        return commitment;\n      }\n\n    default:\n      {\n        return \"singleGossip\";\n      }\n  }\n})();\n\nfunction isTrackedCommitment(commitment) {\n  switch (commitment) {\n    case \"single\":\n    case \"singleGossip\":\n    case \"recent\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexport let ActionType;\n\n(function (ActionType) {\n  ActionType[ActionType[\"NewTransaction\"] = 0] = \"NewTransaction\";\n  ActionType[ActionType[\"UpdateIds\"] = 1] = \"UpdateIds\";\n  ActionType[ActionType[\"TimeoutTransaction\"] = 2] = \"TimeoutTransaction\";\n  ActionType[ActionType[\"ResetState\"] = 3] = \"ResetState\";\n  ActionType[ActionType[\"RecordRoot\"] = 4] = \"RecordRoot\";\n})(ActionType || (ActionType = {}));\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case ActionType.NewTransaction:\n      {\n        const {\n          details,\n          pendingTransaction\n        } = action;\n        return [...state, {\n          details,\n          status: \"pending\",\n          pending: pendingTransaction\n        }];\n      }\n\n    case ActionType.TimeoutTransaction:\n      {\n        const trackingId = action.trackingId;\n        if (trackingId >= state.length) return state;\n        const timeout = state[trackingId];\n        if (timeout.status !== \"pending\") return state;\n        clearInterval(timeout.pending.retryId);\n        return state.map(tx => {\n          if (tx.details.signature === timeout.details.signature) {\n            return {\n              status: \"timeout\",\n              details: tx.details\n            };\n          } else {\n            return tx;\n          }\n        });\n      }\n\n    case ActionType.UpdateIds:\n      {\n        const {\n          ids,\n          partition,\n          partitionCount\n        } = action.activeIdPartition;\n        return state.map((tx, trackingId) => {\n          if (trackingId % partitionCount !== partition) return tx;\n          const id = Math.floor(trackingId / partitionCount);\n\n          if (tx.status === \"pending\" && ids.has(id)) {\n            const timing = {\n              sentAt: tx.pending.sentAt\n            };\n\n            if (isTrackedCommitment(action.commitment)) {\n              timing[action.commitment] = timeElapsed(tx.pending.sentAt);\n            }\n\n            if (action.commitment === \"singleGossip\" || action.commitment === \"single\") {\n              clearInterval(tx.pending.retryId);\n            }\n\n            return {\n              status: \"success\",\n              details: tx.details,\n              slot: {\n                target: tx.pending.targetSlot,\n                estimated: action.estimatedSlot\n              },\n              timing,\n              pending: { ...tx.pending\n              }\n            };\n          } else if (tx.status === \"success\") {\n            if (ids.has(id)) {\n              const currentTiming = tx.timing;\n\n              if (tx.pending && (action.commitment === \"singleGossip\" || action.commitment === \"single\")) {\n                clearInterval(tx.pending.retryId);\n              }\n\n              const timing = { ...currentTiming\n              };\n\n              if (isTrackedCommitment(action.commitment)) {\n                timing[action.commitment] = timeElapsed(timing.sentAt);\n              }\n\n              return { ...tx,\n                timing\n              };\n            } else if (tx.pending && !ids.has(id)) {\n              return {\n                status: \"pending\",\n                details: tx.details,\n                pending: { ...tx.pending\n                }\n              };\n            }\n          }\n\n          return tx;\n        });\n      }\n\n    case ActionType.ResetState:\n      {\n        state.forEach(tx => {\n          if (tx.status === \"pending\") {\n            clearTimeout(tx.pending.timeoutId);\n            clearInterval(tx.pending.retryId);\n          } else if (tx.status === \"success\" && tx.pending) {\n            clearTimeout(tx.pending.timeoutId);\n            clearInterval(tx.pending.retryId);\n          }\n        });\n        return [];\n      }\n  }\n}\n\nconst SlotContext = React.createContext(undefined);\nconst StateContext = React.createContext(undefined);\nconst DispatchContext = React.createContext(undefined);\nexport function TransactionsProvider({\n  children\n}) {\n  const [state, dispatch] = React.useReducer(reducer, []);\n  const connection = useConnection();\n  const targetSlot = React.useRef();\n  React.useEffect(() => {\n    dispatch({\n      type: ActionType.ResetState\n    });\n    if (connection === undefined) return;\n    const slotSubscription = connection.onSlotChange(({\n      slot\n    }) => {\n      targetSlot.current = slot;\n    });\n    return () => {\n      connection.removeSlotChangeListener(slotSubscription);\n    };\n  }, [connection]);\n  return /*#__PURE__*/React.createElement(StateContext.Provider, {\n    value: state,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 257,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(DispatchContext.Provider, {\n    value: dispatch,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 258,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(SlotContext.Provider, {\n    value: targetSlot,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 259,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(SelectedTxProvider, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 260,\n      columnNumber: 11\n    }\n  }, /*#__PURE__*/React.createElement(ConfirmedHelper, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 261,\n      columnNumber: 13\n    }\n  }, /*#__PURE__*/React.createElement(TpsProvider, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 262,\n      columnNumber: 15\n    }\n  }, children))))));\n}\n\nfunction timeElapsed(sentAt) {\n  const now = performance.now();\n  return parseFloat(((now - sentAt) / 1000).toFixed(3));\n}\n\nexport function useDispatch() {\n  const dispatch = React.useContext(DispatchContext);\n\n  if (!dispatch) {\n    throw new Error(`useDispatch must be used within a TransactionsProvider`);\n  }\n\n  return dispatch;\n}\nexport function useTargetSlotRef() {\n  const dispatch = React.useContext(SlotContext);\n\n  if (!dispatch) {\n    throw new Error(`useTargetSlotRef must be used within a TransactionsProvider`);\n  }\n\n  return dispatch;\n}\nexport function useTransactions() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useTransactions must be used within a TransactionsProvider`);\n  }\n\n  return state;\n}\nexport function useConfirmedCount() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useConfirmedCount must be used within a TransactionsProvider`);\n  }\n\n  return state.filter(({\n    status\n  }) => status === \"success\").length;\n}\nexport function useDroppedCount() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useDroppedCount must be used within a TransactionsProvider`);\n  }\n\n  return state.filter(({\n    status\n  }) => status === \"timeout\").length;\n}\nexport function useAvgConfirmationTime() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useAvgConfirmationTime must be used within a TransactionsProvider`);\n  }\n\n  const confirmed = state.reduce((confirmed, tx) => {\n    if (tx.status === \"success\") {\n      const confTime = tx.timing[COMMITMENT_PARAM];\n      if (confTime !== undefined) confirmed.push(confTime);\n    }\n\n    return confirmed;\n  }, []);\n  const count = confirmed.length;\n  if (count === 0) return 0;\n  const sum = confirmed.reduce((sum, time) => sum + time, 0);\n  return sum / count;\n}\nexport function useCreatedCount() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useCreatedCount must be used within a TransactionsProvider`);\n  }\n\n  return state.length;\n}\nexport function useTps() {\n  const tps = React.useContext(TpsContext);\n  if (tps === undefined) throw new Error(`useTps must be used within a TransactionsProvider`);\n  return tps;\n}\nexport function useCreateTx() {\n  const config = useConfig();\n  const accounts = useAccounts();\n  const idCounter = React.useRef(0);\n  const targetSlotRef = useTargetSlotRef();\n  const programDataAccount = accounts === null || accounts === void 0 ? void 0 : accounts.programAccounts[0].toBase58(); // Reset counter when program data accounts are refreshed\n\n  React.useEffect(() => {\n    idCounter.current = 0;\n  }, [programDataAccount]);\n  const blockhash = useBlockhash();\n  const dispatch = useDispatch();\n  const socket = useSocket();\n  return React.useCallback(() => {\n    if (!blockhash || !socket || !config || !accounts || !targetSlotRef.current) return;\n    const id = idCounter.current;\n\n    if (id < accounts.accountCapacity * accounts.programAccounts.length) {\n      idCounter.current++;\n      createTransaction(blockhash, targetSlotRef.current, config.programId, accounts, id, dispatch, socket);\n    } else {\n      reportError(new Error(\"Account capacity exceeded\"), \"failed to create transaction\");\n    }\n  }, [blockhash, socket, config, accounts, dispatch, targetSlotRef]);\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/transactions/index.tsx"],"names":["React","useConfig","useAccounts","useConnection","useBlockhash","ConfirmedHelper","TpsProvider","TpsContext","createTransaction","SelectedTxProvider","useSocket","reportError","COMMITMENT_PARAM","commitment","URLSearchParams","window","location","search","get","isTrackedCommitment","ActionType","reducer","state","action","type","NewTransaction","details","pendingTransaction","status","pending","TimeoutTransaction","trackingId","length","timeout","clearInterval","retryId","map","tx","signature","UpdateIds","ids","partition","partitionCount","activeIdPartition","id","Math","floor","has","timing","sentAt","timeElapsed","slot","target","targetSlot","estimated","estimatedSlot","currentTiming","ResetState","forEach","clearTimeout","timeoutId","SlotContext","createContext","undefined","StateContext","DispatchContext","TransactionsProvider","children","dispatch","useReducer","connection","useRef","useEffect","slotSubscription","onSlotChange","current","removeSlotChangeListener","now","performance","parseFloat","toFixed","useDispatch","useContext","Error","useTargetSlotRef","useTransactions","useConfirmedCount","filter","useDroppedCount","useAvgConfirmationTime","confirmed","reduce","confTime","push","count","sum","time","useCreatedCount","useTps","tps","useCreateTx","config","accounts","idCounter","targetSlotRef","programDataAccount","programAccounts","toBase58","blockhash","socket","useCallback","accountCapacity","programId"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { TransactionSignature, PublicKey, Commitment } from \"@solana/web3.js\";\nimport { useConfig, useAccounts, useConnection } from \"../api\";\nimport { useBlockhash } from \"../blockhash\";\nimport { ConfirmedHelper } from \"./confirmed\";\nimport { TpsProvider, TpsContext } from \"./tps\";\nimport { createTransaction } from \"./create\";\nimport { SelectedTxProvider } from \"./selected\";\nimport { useSocket } from \"../socket\";\nimport { reportError } from \"utils\";\n\nexport type PendingTransaction = {\n  sentAt: number;\n  targetSlot: number;\n  retryId?: number;\n  timeoutId?: number;\n};\n\nexport type TransactionDetails = {\n  id: number;\n  feeAccount: PublicKey;\n  programAccount: PublicKey;\n  signature: TransactionSignature;\n};\n\ntype Timing = {\n  sentAt: number;\n  recent?: number;\n  single?: number;\n  singleGossip?: number;\n};\n\ntype SuccessState = {\n  status: \"success\";\n  details: TransactionDetails;\n  slot: {\n    target: number;\n    landed?: number;\n    estimated: number;\n  };\n  timing: Timing;\n  pending?: PendingTransaction;\n};\n\nexport const COMMITMENT_PARAM = ((): TrackedCommitment => {\n  const commitment = new URLSearchParams(window.location.search).get(\n    \"commitment\"\n  );\n  switch (commitment) {\n    case \"recent\":\n    case \"single\": {\n      return commitment;\n    }\n    default: {\n      return \"singleGossip\";\n    }\n  }\n})();\n\nexport type TrackedCommitment = \"single\" | \"singleGossip\" | \"recent\";\nfunction isTrackedCommitment(commitment: Commitment): commitment is TrackedCommitment {\n  switch (commitment) {\n    case \"single\":\n    case \"singleGossip\":\n    case \"recent\":\n      return true;\n    default:\n      return false;\n  }\n}\n\ntype TimeoutState = {\n  status: \"timeout\";\n  details: TransactionDetails;\n};\n\ntype PendingState = {\n  status: \"pending\";\n  pending: PendingTransaction;\n  details: TransactionDetails;\n};\n\nexport type TransactionStatus = \"success\" | \"timeout\" | \"pending\";\n\nexport type TransactionState = SuccessState | TimeoutState | PendingState;\n\nexport enum ActionType {\n  NewTransaction,\n  UpdateIds,\n  TimeoutTransaction,\n  ResetState,\n  RecordRoot,\n}\n\ntype UpdateIds = {\n  type: ActionType.UpdateIds;\n  activeIdPartition: {\n    ids: Set<number>;\n    partition: number;\n    partitionCount: number;\n  };\n  commitment: Commitment;\n  estimatedSlot: number;\n};\n\ntype NewTransaction = {\n  type: ActionType.NewTransaction;\n  trackingId: number;\n  details: TransactionDetails;\n  pendingTransaction: PendingTransaction;\n};\n\ntype TimeoutTransaction = {\n  type: ActionType.TimeoutTransaction;\n  trackingId: number;\n};\n\ntype ResetState = {\n  type: ActionType.ResetState;\n};\n\ntype Action =\n  | NewTransaction\n  | UpdateIds\n  | TimeoutTransaction\n  | ResetState;\n\ntype State = TransactionState[];\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case ActionType.NewTransaction: {\n      const { details, pendingTransaction } = action;\n      return [\n        ...state,\n        {\n          details,\n          status: \"pending\",\n          pending: pendingTransaction,\n        },\n      ];\n    }\n\n    case ActionType.TimeoutTransaction: {\n      const trackingId = action.trackingId;\n      if (trackingId >= state.length) return state;\n      const timeout = state[trackingId];\n      if (timeout.status !== \"pending\") return state;\n      clearInterval(timeout.pending.retryId);\n\n      return state.map((tx) => {\n        if (tx.details.signature === timeout.details.signature) {\n          return {\n            status: \"timeout\",\n            details: tx.details,\n          };\n        } else {\n          return tx;\n        }\n      });\n    }\n\n    case ActionType.UpdateIds: {\n      const { ids, partition, partitionCount } = action.activeIdPartition;\n      return state.map((tx, trackingId) => {\n        if (trackingId % partitionCount !== partition) return tx;\n        const id = Math.floor(trackingId / partitionCount);\n        if (tx.status === \"pending\" && ids.has(id)) {\n          const timing: Timing = {sentAt: tx.pending.sentAt};\n          if (isTrackedCommitment(action.commitment)) {\n            timing[action.commitment] = timeElapsed(tx.pending.sentAt);\n          }\n          if (action.commitment === \"singleGossip\" || action.commitment === \"single\") {\n            clearInterval(tx.pending.retryId);\n          }\n          return {\n            status: \"success\",\n            details: tx.details,\n            slot: {\n              target: tx.pending.targetSlot,\n              estimated: action.estimatedSlot,\n            },\n            timing,\n            pending: { ...tx.pending },\n          };\n        } else if (tx.status === \"success\") {\n          if (ids.has(id)) {\n            const currentTiming = tx.timing;\n            if (tx.pending && (action.commitment === \"singleGossip\" || action.commitment === \"single\")) {\n              clearInterval(tx.pending.retryId);\n            }\n            const timing: Timing = {\n              ...currentTiming,\n            };\n            if (isTrackedCommitment(action.commitment)) {\n              timing[action.commitment] = timeElapsed(timing.sentAt);\n            }\n            return {\n              ...tx,\n              timing,\n            };\n          } else if (tx.pending && !ids.has(id)) {\n            return {\n              status: \"pending\",\n              details: tx.details,\n              pending: { ...tx.pending },\n            };\n          }\n        } \n        return tx;\n      });\n    }\n\n    case ActionType.ResetState: {\n      state.forEach((tx) => {\n        if (tx.status === \"pending\") {\n          clearTimeout(tx.pending.timeoutId);\n          clearInterval(tx.pending.retryId);\n        } else if (tx.status === \"success\" && tx.pending) {\n          clearTimeout(tx.pending.timeoutId);\n          clearInterval(tx.pending.retryId);\n        }\n      });\n      return [];\n    }\n  }\n}\n\nexport type Dispatch = (action: Action) => void;\nconst SlotContext = React.createContext<\n  React.MutableRefObject<number | undefined> | undefined\n>(undefined);\nconst StateContext = React.createContext<State | undefined>(undefined);\nconst DispatchContext = React.createContext<Dispatch | undefined>(undefined);\n\ntype ProviderProps = { children: React.ReactNode };\nexport function TransactionsProvider({ children }: ProviderProps) {\n  const [state, dispatch] = React.useReducer(reducer, []);\n  const connection = useConnection();\n  const targetSlot = React.useRef<number>();\n\n  React.useEffect(() => {\n    dispatch({\n      type: ActionType.ResetState,\n    });\n\n    if (connection === undefined) return;\n    const slotSubscription = connection.onSlotChange(({ slot }) => {\n      targetSlot.current = slot;\n    });\n\n    return () => {\n      connection.removeSlotChangeListener(slotSubscription);\n    };\n  }, [connection]);\n\n  return (\n    <StateContext.Provider value={state}>\n      <DispatchContext.Provider value={dispatch}>\n        <SlotContext.Provider value={targetSlot}>\n          <SelectedTxProvider>\n            <ConfirmedHelper>\n              <TpsProvider>{children}</TpsProvider>\n            </ConfirmedHelper>\n          </SelectedTxProvider>\n        </SlotContext.Provider>\n      </DispatchContext.Provider>\n    </StateContext.Provider>\n  );\n}\n\nfunction timeElapsed(sentAt: number): number {\n  const now = performance.now();\n  return parseFloat(((now - sentAt) / 1000).toFixed(3));\n}\n\nexport function useDispatch() {\n  const dispatch = React.useContext(DispatchContext);\n  if (!dispatch) {\n    throw new Error(`useDispatch must be used within a TransactionsProvider`);\n  }\n\n  return dispatch;\n}\n\nexport function useTargetSlotRef() {\n  const dispatch = React.useContext(SlotContext);\n  if (!dispatch) {\n    throw new Error(\n      `useTargetSlotRef must be used within a TransactionsProvider`\n    );\n  }\n\n  return dispatch;\n}\n\nexport function useTransactions() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useTransactions must be used within a TransactionsProvider`\n    );\n  }\n\n  return state;\n}\n\nexport function useConfirmedCount() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useConfirmedCount must be used within a TransactionsProvider`\n    );\n  }\n  return state.filter(({ status }) => status === \"success\").length;\n}\n\nexport function useDroppedCount() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useDroppedCount must be used within a TransactionsProvider`\n    );\n  }\n  return state.filter(({ status }) => status === \"timeout\").length;\n}\n\nexport function useAvgConfirmationTime() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useAvgConfirmationTime must be used within a TransactionsProvider`\n    );\n  }\n\n  const confirmed = state.reduce((confirmed: number[], tx) => {\n    if (tx.status === \"success\") {\n      const confTime = tx.timing[COMMITMENT_PARAM];\n      if (confTime !== undefined) confirmed.push(confTime);\n    }\n    return confirmed;\n  }, []);\n\n  const count = confirmed.length;\n  if (count === 0) return 0;\n  const sum = confirmed.reduce((sum, time) => sum + time, 0);\n  return sum / count;\n}\n\nexport function useCreatedCount() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(\n      `useCreatedCount must be used within a TransactionsProvider`\n    );\n  }\n  return state.length;\n}\n\nexport function useTps() {\n  const tps = React.useContext(TpsContext);\n  if (tps === undefined)\n    throw new Error(`useTps must be used within a TransactionsProvider`);\n  return tps;\n}\n\nexport function useCreateTx() {\n  const config = useConfig();\n  const accounts = useAccounts();\n  const idCounter = React.useRef<number>(0);\n  const targetSlotRef = useTargetSlotRef();\n  const programDataAccount = accounts?.programAccounts[0].toBase58();\n\n  // Reset counter when program data accounts are refreshed\n  React.useEffect(() => {\n    idCounter.current = 0;\n  }, [programDataAccount]);\n\n  const blockhash = useBlockhash();\n  const dispatch = useDispatch();\n  const socket = useSocket();\n  return React.useCallback(() => {\n    if (!blockhash || !socket || !config || !accounts || !targetSlotRef.current)\n      return;\n    const id = idCounter.current;\n    if (id < accounts.accountCapacity * accounts.programAccounts.length) {\n      idCounter.current++;\n      createTransaction(\n        blockhash,\n        targetSlotRef.current,\n        config.programId,\n        accounts,\n        id,\n        dispatch,\n        socket\n      );\n    } else {\n      reportError(\n        new Error(\"Account capacity exceeded\"),\n        \"failed to create transaction\"\n      );\n    }\n  }, [blockhash, socket, config, accounts, dispatch, targetSlotRef]);\n}\n"]},"metadata":{},"sourceType":"module"}