{"ast":null,"code":"var _jsxFileName = \"/Users/jstarry/Workspace/solana/break/client/src/providers/rpc/blockhash.tsx\";\nimport * as React from \"react\";\nimport { sleep, reportError } from \"utils\";\nimport { useConnection } from \".\";\nconst POLL_INTERVAL_MS = 20000;\nexport let ActionType;\n\n(function (ActionType) {\n  ActionType[ActionType[\"Start\"] = 0] = \"Start\";\n  ActionType[ActionType[\"Stop\"] = 1] = \"Stop\";\n  ActionType[ActionType[\"Update\"] = 2] = \"Update\";\n})(ActionType || (ActionType = {}));\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case ActionType.Stop:\n      {\n        return {};\n      }\n\n    case ActionType.Update:\n      {\n        return Object.assign({}, state, {\n          blockhash: action.blockhash\n        });\n      }\n  }\n}\n\nconst StateContext = React.createContext(undefined);\nconst DispatchContext = React.createContext(undefined);\nexport function BlockhashProvider({\n  children\n}) {\n  const [state, dispatch] = React.useReducer(reducer, {});\n  const connection = useConnection();\n  const connectionRef = React.useRef(connection);\n  const refreshingRef = React.useRef(false);\n  React.useEffect(() => {\n    if (connection === undefined) return;\n    connectionRef.current = connection;\n    refresh(dispatch, connectionRef, refreshingRef);\n    const timerId = window.setInterval(() => refresh(dispatch, connectionRef, refreshingRef), POLL_INTERVAL_MS);\n    return () => {\n      clearInterval(timerId);\n      dispatch({\n        type: ActionType.Stop\n      });\n    };\n  }, [connection]);\n  return /*#__PURE__*/React.createElement(StateContext.Provider, {\n    value: state,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(DispatchContext.Provider, {\n    value: dispatch,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 71,\n      columnNumber: 7\n    }\n  }, children));\n}\nexport function useBlockhash() {\n  const state = React.useContext(StateContext);\n\n  if (!state) {\n    throw new Error(`useBlockhash must be used within a BlockhashProvider`);\n  }\n\n  return state.blockhash;\n}\n\nasync function refresh(dispatch, connectionRef, refreshingRef) {\n  let blockhash = undefined;\n  const connection = connectionRef.current;\n  if (connection === undefined) return;\n  if (refreshingRef.current) return;\n  refreshingRef.current = true;\n  let reported = false;\n\n  while (blockhash === undefined && connection === connectionRef.current) {\n    try {\n      blockhash = (await connection.getRecentBlockhash(\"max\")).blockhash;\n      dispatch({\n        type: ActionType.Update,\n        blockhash\n      });\n    } catch (err) {\n      if (!reported) reportError(err, \"Failed to refresh blockhash\");\n      reported = true;\n      await sleep(1000);\n    }\n  }\n\n  refreshingRef.current = false;\n}","map":{"version":3,"sources":["/Users/jstarry/Workspace/solana/break/client/src/providers/rpc/blockhash.tsx"],"names":["React","sleep","reportError","useConnection","POLL_INTERVAL_MS","ActionType","reducer","state","action","type","Stop","Update","Object","assign","blockhash","StateContext","createContext","undefined","DispatchContext","BlockhashProvider","children","dispatch","useReducer","connection","connectionRef","useRef","refreshingRef","useEffect","current","refresh","timerId","window","setInterval","clearInterval","useBlockhash","useContext","Error","reported","getRecentBlockhash","err"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { Blockhash, Connection } from \"@solana/web3.js\";\nimport { sleep, reportError } from \"utils\";\nimport { useConnection } from \".\";\n\nconst POLL_INTERVAL_MS = 20000;\n\nexport enum ActionType {\n  Start,\n  Stop,\n  Update,\n}\n\ninterface Stop {\n  type: ActionType.Stop;\n}\n\ninterface Update {\n  type: ActionType.Update;\n  blockhash: Blockhash;\n}\n\ninterface State {\n  blockhash?: Blockhash;\n}\n\ntype Action = Stop | Update;\ntype Dispatch = (action: Action) => void;\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case ActionType.Stop: {\n      return {};\n    }\n    case ActionType.Update: {\n      return Object.assign({}, state, {\n        blockhash: action.blockhash,\n      });\n    }\n  }\n}\n\nconst StateContext = React.createContext<State | undefined>(undefined);\nconst DispatchContext = React.createContext<Dispatch | undefined>(undefined);\n\ntype BlockhashProviderProps = { children: React.ReactNode };\nexport function BlockhashProvider({ children }: BlockhashProviderProps) {\n  const [state, dispatch] = React.useReducer(reducer, {});\n  const connection = useConnection();\n  const connectionRef = React.useRef(connection);\n  const refreshingRef = React.useRef(false);\n\n  React.useEffect(() => {\n    if (connection === undefined) return;\n\n    connectionRef.current = connection;\n    refresh(dispatch, connectionRef, refreshingRef);\n    const timerId = window.setInterval(\n      () => refresh(dispatch, connectionRef, refreshingRef),\n      POLL_INTERVAL_MS\n    );\n\n    return () => {\n      clearInterval(timerId);\n      dispatch({ type: ActionType.Stop });\n    };\n  }, [connection]);\n\n  return (\n    <StateContext.Provider value={state}>\n      <DispatchContext.Provider value={dispatch}>\n        {children}\n      </DispatchContext.Provider>\n    </StateContext.Provider>\n  );\n}\n\nexport function useBlockhash() {\n  const state = React.useContext(StateContext);\n  if (!state) {\n    throw new Error(`useBlockhash must be used within a BlockhashProvider`);\n  }\n\n  return state.blockhash;\n}\n\nasync function refresh(\n  dispatch: Dispatch,\n  connectionRef: React.MutableRefObject<Connection | undefined>,\n  refreshingRef: React.MutableRefObject<boolean>,\n) {\n  let blockhash = undefined;\n  const connection = connectionRef.current;\n  if (connection === undefined) return;\n\n  if (refreshingRef.current) return;\n  refreshingRef.current = true;\n\n  let reported = false;\n  while (blockhash === undefined && connection === connectionRef.current) {\n    try {\n      blockhash = (await connection.getRecentBlockhash(\"max\")).blockhash;\n      dispatch({ type: ActionType.Update, blockhash });\n    } catch (err) {\n      if (!reported) reportError(err, \"Failed to refresh blockhash\");\n      reported = true;\n      await sleep(1000);\n    }\n  }\n\n  refreshingRef.current = false;\n}\n"]},"metadata":{},"sourceType":"module"}